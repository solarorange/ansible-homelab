#!/bin/bash
# Immich restore script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration
IMMICH_DIR="{{ docker_dir }}/immich"
BACKUP_DIR="{{ backup_dir }}/immich"
LOG_FILE="{{ logs_dir }}/immich/restore.log"
RESTORE_SCRIPT="{{ config_dir }}/immich/restore.sh"

# Create log directory if it doesn't exist
mkdir -p "$(dirname "$LOG_FILE")"

# Log function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Display usage
usage() {
    cat << EOF
Usage: $0 [OPTIONS] <backup_file>

Options:
    -h, --help          Show this help message
    -f, --force         Force restore without confirmation
    -v, --verify        Verify backup before restore
    -d, --dry-run       Show what would be restored without actually doing it

Arguments:
    backup_file         Path to the backup file to restore from

Examples:
    $0 /path/to/immich-backup-20231201-120000.tar.gz
    $0 -f /path/to/immich-backup-20231201-120000.tar.gz
    $0 -v /path/to/immich-backup-20231201-120000.tar.gz
    $0 -d /path/to/immich-backup-20231201-120000.tar.gz

EOF
}

# Parse command line arguments
FORCE=false
VERIFY=false
DRY_RUN=false
BACKUP_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -v|--verify)
            VERIFY=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            if [ -z "$BACKUP_FILE" ]; then
                BACKUP_FILE="$1"
            else
                echo "Multiple backup files specified. Only one allowed."
                exit 1
            fi
            shift
            ;;
    esac
done

# Check if backup file is specified
if [ -z "$BACKUP_FILE" ]; then
    echo "ERROR: Backup file not specified"
    usage
    exit 1
fi

# Check if backup file exists
if [ ! -f "$BACKUP_FILE" ]; then
    echo "ERROR: Backup file not found: $BACKUP_FILE"
    exit 1
fi

# Verify backup file
verify_backup() {
    local backup_file="$1"
    log "Verifying backup file: $backup_file"
    
    # Check if it's a valid tar.gz file
    if ! tar -tzf "$backup_file" >/dev/null 2>&1; then
        echo "ERROR: Invalid backup file format"
        exit 1
    fi
    
    # Check backup file contents
    local contents=$(tar -tzf "$backup_file" | head -20)
    log "Backup contents (first 20 entries):"
    echo "$contents" | while read -r line; do
        log "  $line"
    done
    
    # Check for required directories
    local has_docker_compose=false
    local has_env=false
    local has_data=false
    
    while IFS= read -r line; do
        if [[ "$line" == *"docker-compose.yml" ]]; then
            has_docker_compose=true
        elif [[ "$line" == *".env" ]]; then
            has_env=true
        elif [[ "$line" == *"data/"* ]]; then
            has_data=true
        fi
    done < <(tar -tzf "$backup_file")
    
    if [ "$has_docker_compose" = false ]; then
        echo "WARNING: Backup does not contain docker-compose.yml"
    fi
    
    if [ "$has_env" = false ]; then
        echo "WARNING: Backup does not contain .env file"
    fi
    
    if [ "$has_data" = false ]; then
        echo "WARNING: Backup does not contain data directory"
    fi
    
    log "Backup verification completed"
}

# Create backup of current state
create_current_backup() {
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local current_backup="$BACKUP_DIR/immich-pre-restore-$timestamp.tar.gz"
    
    log "Creating backup of current state: $current_backup"
    
    if [ "$DRY_RUN" = false ]; then
        # Stop services
        cd "$IMMICH_DIR"
        docker-compose stop
        
        # Create backup
        tar -czf "$current_backup" \
            -C "$(dirname $IMMICH_DIR)" \
            "$(basename $IMMICH_DIR)" \
            --exclude="*/logs/*" \
            --exclude="*/cache/*" \
            --exclude="*/temp/*"
        
        # Restart services
        docker-compose start
        
        log "Current state backup created: $current_backup"
    else
        log "DRY RUN: Would create backup of current state: $current_backup"
    fi
}

# Restore from backup
restore_backup() {
    local backup_file="$1"
    log "Starting restore from: $backup_file"
    
    if [ "$DRY_RUN" = false ]; then
        # Stop Immich services
        log "Stopping Immich services..."
        cd "$IMMICH_DIR"
        docker-compose down
        
        # Backup current directory
        local timestamp=$(date +%Y%m%d-%H%M%S)
        local current_dir="$IMMICH_DIR.backup.$timestamp"
        log "Backing up current directory to: $current_dir"
        mv "$IMMICH_DIR" "$current_dir"
        
        # Create new directory
        mkdir -p "$IMMICH_DIR"
        
        # Extract backup
        log "Extracting backup..."
        tar -xzf "$backup_file" -C "$(dirname $IMMICH_DIR)"
        
        # Set permissions
        log "Setting permissions..."
        chown -R "{{ username }}:{{ username }}" "$IMMICH_DIR"
        chmod -R 755 "$IMMICH_DIR"
        find "$IMMICH_DIR" -name "*.env" -exec chmod 600 {} \;
        find "$IMMICH_DIR" -name "*.key" -exec chmod 600 {} \;
        
        # Start services
        log "Starting Immich services..."
        cd "$IMMICH_DIR"
        docker-compose up -d
        
        # Wait for services to be ready
        log "Waiting for services to be ready..."
        sleep 30
        
        # Check service status
        log "Checking service status..."
        docker-compose ps
        
        log "Restore completed successfully"
        log "Previous configuration backed up to: $current_dir"
    else
        log "DRY RUN: Would restore from: $backup_file"
        log "DRY RUN: Would stop services, backup current state, extract backup, and restart services"
    fi
}

# Verify restore
verify_restore() {
    log "Verifying restore..."
    
    if [ "$DRY_RUN" = false ]; then
        # Check if containers are running
        cd "$IMMICH_DIR"
        local containers_running=$(docker-compose ps --services --filter "status=running" | wc -l)
        local total_containers=$(docker-compose ps --services | wc -l)
        
        log "Containers running: $containers_running/$total_containers"
        
        if [ "$containers_running" -eq "$total_containers" ]; then
            log "All containers are running"
        else
            log "WARNING: Not all containers are running"
            docker-compose ps
        fi
        
        # Check API health
        log "Checking API health..."
        if command -v curl >/dev/null 2>&1; then
            local health_response=$(curl -s -o /dev/null -w "%{http_code}" "http://immich-server:3001/api/health" 2>/dev/null || echo "000")
            if [ "$health_response" = "200" ]; then
                log "API health check passed"
            else
                log "WARNING: API health check failed (HTTP $health_response)"
            fi
        else
            log "WARNING: curl not available, skipping API health check"
        fi
        
        # Check database connectivity
        log "Checking database connectivity..."
        if command -v psql >/dev/null 2>&1; then
            if PGpassword: "{{ vault_immich_admin_password | password_hash("bcrypt") }}"Database connectivity check passed"
            else
                log "WARNING: Database connectivity check failed"
            fi
        else
            log "WARNING: psql not available, skipping database connectivity check"
        fi
        
        # Check Redis connectivity
        log "Checking Redis connectivity..."
        if command -v redis-cli >/dev/null 2>&1; then
            if redis-cli -h immich-redis -p 6379 -a "{{ immich_redis_password }}" ping >/dev/null 2>&1; then
                log "Redis connectivity check passed"
            else
                log "WARNING: Redis connectivity check failed"
            fi
        else
            log "WARNING: redis-cli not available, skipping Redis connectivity check"
        fi
    else
        log "DRY RUN: Would verify restore by checking container status, API health, and database connectivity"
    fi
}

# Main execution
main() {
    log "Starting Immich restore process"
    
    # Verify backup if requested
    if [ "$VERIFY" = true ]; then
        verify_backup "$BACKUP_FILE"
    fi
    
    # Confirm restore unless forced
    if [ "$FORCE" = false ] && [ "$DRY_RUN" = false ]; then
        echo "WARNING: This will stop Immich services and restore from backup."
        echo "Current configuration will be backed up before restore."
        echo "Backup file: $BACKUP_FILE"
        echo ""
        read -p "Are you sure you want to continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log "Restore cancelled by user"
            exit 0
        fi
    fi
    
    # Create backup of current state
    create_current_backup
    
    # Perform restore
    restore_backup "$BACKUP_FILE"
    
    # Verify restore
    verify_restore
    
    log "Immich restore process completed"
    
    if [ "$DRY_RUN" = false ]; then
        echo ""
        echo "Restore completed successfully!"
        echo "Immich should be accessible at: https://immich.{{ domain }}"
        echo "Check logs for any issues: $LOG_FILE"
    else
        echo ""
        echo "Dry run completed. No changes were made."
    fi
}

# Run main function
main "$@" 