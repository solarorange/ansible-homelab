#!/bin/bash
# COMMENT: Production-ready Rollback Execution Script
# COMMENT: Comprehensive rollback procedures with security validation and error handling
# COMMENT: Generated by: {{ ansible_managed }}
# COMMENT: Timestamp: {{ ansible_date_time.iso8601 }}
# COMMENT: Environment: {{ deployment_environment | default('production') }}

# COMMENT: Production security settings for rollback reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="rollback-execute.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROLLBACK_DIR="{{ rollback_script_config.rollback_dir }}"
DOCKER_DIR="{{ rollback_script_config.docker_dir }}"
BACKUP_USER="{{ rollback_script_config.backup_user }}"
BACKUP_GROUP="{{ rollback_script_config.backup_group }}"
VALIDATION_TIMEOUT="{{ rollback_script_config.validation_timeout }}"
VALIDATION_RETRIES="{{ rollback_script_config.validation_retries }}"
PID_FILE="/tmp/rollback_script.pid"
LOCK_FILE="/tmp/rollback_script.lock"
LOG_FILE="$ROLLBACK_DIR/rollback.log"

# COMMENT: Production environment variables with validation
export ROLLBACK_ENVIRONMENT="{{ deployment_environment | default('production') }}"
export ROLLBACK_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"
export ROLLBACK_USER="${USER:-$(whoami)}"

# COMMENT: Production logging function with validation and security
log() {
    local level="$1"
    local message="$2"
    local timestamp="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
    
    # COMMENT: Input validation and sanitization for security
    if [[ -z "$level" || -z "$message" ]]; then
        echo "ERROR: Invalid log parameters" >&2
        return 1
    fi
    
    # COMMENT: Sanitize log level for security
    case "$level" in
        INFO|WARNING|ERROR|CRITICAL|SUCCESS)
            ;;
        *)
            level="INFO"
            ;;
    esac
    
    # COMMENT: Sanitize message for security (remove potential injection)
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# COMMENT: Production error handling with comprehensive cleanup
error_exit() {
    local function_name="$1"
    local error_message="$2"
    local exit_code="${3:-1}"
    
    log "ERROR" "Rollback failed in $function_name: $error_message"
    
    # COMMENT: Cleanup on error
    cleanup_on_exit
    
    # COMMENT: Send error notification if configured
    send_error_notification "$function_name" "$error_message"
    
    exit "$exit_code"
}

# COMMENT: Signal handling for production rollback
cleanup_on_exit() {
    # COMMENT: Remove PID and lock files
    [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
    [[ -f "$LOCK_FILE" ]] && rm -f "$LOCK_FILE"
    
    # COMMENT: Log cleanup completion
    log "INFO" "Cleanup completed on exit"
}

# COMMENT: Signal handlers for production safety
trap cleanup_on_exit EXIT
trap 'error_exit "signal_handler" "Received interrupt signal" 130' INT TERM

# COMMENT: Production rollback locking for concurrency control
acquire_rollback_lock() {
    if [[ -f "$LOCK_FILE" ]]; then
        local lock_pid
        lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
        
        if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
            error_exit "acquire_rollback_lock" "Rollback already running (PID: $lock_pid)"
        else
            # COMMENT: Remove stale lock file
            rm -f "$LOCK_FILE"
        fi
    fi
    
    # COMMENT: Create lock file with current PID
    echo $$ > "$LOCK_FILE"
    echo $$ > "$PID_FILE"
    
    log "INFO" "Rollback lock acquired (PID: $$)"
}

# COMMENT: Release rollback lock
release_rollback_lock() {
    rm -f "$LOCK_FILE" "$PID_FILE"
    log "INFO" "Rollback lock released"
}

# COMMENT: Production prerequisite validation with security
check_prerequisites() {
    log "INFO" "Validating production rollback prerequisites..."
    
    # COMMENT: Check script permissions and ownership
    if [[ ! -r "$0" ]]; then
        error_exit "check_prerequisites" "Script is not readable"
    fi
    
    # COMMENT: Validate rollback directory
    if [[ ! -d "$ROLLBACK_DIR" ]]; then
        error_exit "check_prerequisites" "Rollback directory not found: $ROLLBACK_DIR"
    fi
    
    # COMMENT: Validate Docker directory
    if [[ ! -d "$DOCKER_DIR" ]]; then
        error_exit "check_prerequisites" "Docker directory not found: $DOCKER_DIR"
    fi
    
    # COMMENT: Check Docker service status
    if ! systemctl is-active --quiet docker; then
        error_exit "check_prerequisites" "Docker service is not running"
    fi
    
    # COMMENT: Validate rollback timestamp parameter
    if [[ $# -eq 0 ]]; then
        error_exit "check_prerequisites" "Rollback timestamp parameter required"
    fi
    
    local rollback_timestamp="$1"
    if [[ ! "$rollback_timestamp" =~ ^[0-9]{10,}$ ]]; then
        error_exit "check_prerequisites" "Invalid rollback timestamp format: $rollback_timestamp"
    fi
    
    # COMMENT: Check if rollback point exists
    if [[ ! -f "$ROLLBACK_DIR/rollback-point-$rollback_timestamp.json" ]]; then
        error_exit "check_prerequisites" "Rollback point not found: $rollback_timestamp"
    fi
    
    # COMMENT: Validate backup files exist
    local required_files=(
        "rollback-point-$rollback_timestamp.json"
        "config-backup-$rollback_timestamp.tar.gz"
        "service-backup-$rollback_timestamp.tar.gz"
    )
    
    for file in "${required_files[@]}"; do
        if [[ ! -f "$ROLLBACK_DIR/$file" ]]; then
            error_exit "check_prerequisites" "Required backup file not found: $file"
        fi
    done
    
    log "SUCCESS" "Production rollback prerequisites validation completed"
}

# COMMENT: Production backup validation with security
validate_backup_integrity() {
    local rollback_timestamp="$1"
    log "INFO" "Validating backup integrity for timestamp: $rollback_timestamp"
    
    # COMMENT: Validate rollback point metadata
    if ! python3 -m json.tool "$ROLLBACK_DIR/rollback-point-$rollback_timestamp.json" >/dev/null 2>&1; then
        error_exit "validate_backup_integrity" "Invalid rollback point metadata format"
    fi
    
    # COMMENT: Validate configuration backup
    if ! tar -tzf "$ROLLBACK_DIR/config-backup-$rollback_timestamp.tar.gz" >/dev/null 2>&1; then
        error_exit "validate_backup_integrity" "Configuration backup integrity check failed"
    fi
    
    # COMMENT: Validate service backup
    if ! tar -tzf "$ROLLBACK_DIR/service-backup-$rollback_timestamp.tar.gz" >/dev/null 2>&1; then
        error_exit "validate_backup_integrity" "Service backup integrity check failed"
    fi
    
    # COMMENT: Check backup file permissions
    local backup_files=(
        "rollback-point-$rollback_timestamp.json"
        "config-backup-$rollback_timestamp.tar.gz"
        "service-backup-$rollback_timestamp.tar.gz"
    )
    
    for file in "${backup_files[@]}"; do
        local file_perms
        file_perms=$(stat -c "%a" "$ROLLBACK_DIR/$file" 2>/dev/null || stat -f "%Lp" "$ROLLBACK_DIR/$file" 2>/dev/null)
        
        if [[ "$file_perms" != "6"* ]] && [[ "$file_perms" != "7"* ]]; then
            log "WARNING" "Backup file has insecure permissions: $file ($file_perms)"
        fi
    done
    
    log "SUCCESS" "Backup integrity validation completed"
}

# COMMENT: Production service stop with security validation
stop_services() {
    local rollback_timestamp="$1"
    log "INFO" "Stopping services for rollback: $rollback_timestamp"
    
    # COMMENT: Read rollback metadata for service information
    local rollback_metadata
    rollback_metadata=$(python3 -c "
import json
import sys
try:
    with open('$ROLLBACK_DIR/rollback-point-$rollback_timestamp.json', 'r') as f:
        data = json.load(f)
        services = data['rollback_point']['deployment_state']['enabled_services']
        print(' '.join(services))
except Exception as e:
    print(f'ERROR: {e}', file=sys.stderr)
    sys.exit(1)
")
    
    if [[ "$rollback_metadata" == ERROR:* ]]; then
        error_exit "stop_services" "Failed to read rollback metadata: $rollback_metadata"
    fi
    
    # COMMENT: Stop services in reverse dependency order
    local services=($rollback_metadata)
    for ((i=${#services[@]}-1; i>=0; i--)); do
        local service="${services[i]}"
        local service_dir="$DOCKER_DIR/$service"
        
        if [[ -d "$service_dir" ]] && [[ -f "$service_dir/docker-compose.yml" ]]; then
            log "INFO" "Stopping service: $service"
            
            if cd "$service_dir" && docker-compose down --timeout 30; then
                log "SUCCESS" "Service stopped: $service"
            else
                log "WARNING" "Service stop failed: $service (continuing with rollback)"
            fi
        fi
    done
    
    log "SUCCESS" "Service stop operations completed"
}

# COMMENT: Production backup restoration with security validation
restore_backups() {
    local rollback_timestamp="$1"
    log "INFO" "Restoring backups for timestamp: $rollback_timestamp"
    
    # COMMENT: Create temporary restoration directory
    local temp_restore_dir
    temp_restore_dir=$(mktemp -d "$ROLLBACK_DIR/temp_restore_XXXXXX")
    
    # COMMENT: Extract configuration backup
    log "INFO" "Extracting configuration backup"
    if ! tar -xzf "$ROLLBACK_DIR/config-backup-$rollback_timestamp.tar.gz" -C "$temp_restore_dir"; then
        error_exit "restore_backups" "Configuration backup extraction failed"
    fi
    
    # COMMENT: Extract service backup
    log "INFO" "Extracting service backup"
    if ! tar -xzf "$ROLLBACK_DIR/service-backup-$rollback_timestamp.tar.gz" -C "$temp_restore_dir"; then
        error_exit "restore_backups" "Service backup extraction failed"
    fi
    
    # COMMENT: Restore configuration files with security validation
    log "INFO" "Restoring configuration files"
    if [[ -d "$temp_restore_dir/config" ]]; then
        if ! cp -r "$temp_restore_dir/config"/* "$DOCKER_DIR/"; then
            error_exit "restore_backups" "Configuration restoration failed"
        fi
        
        # COMMENT: Set secure permissions
        find "$DOCKER_DIR" -type f -name "*.yml" -exec chmod 640 {} \;
        find "$DOCKER_DIR" -type f -name "*.env" -exec chmod 600 {} \;
        find "$DOCKER_DIR" -type d -exec chmod 750 {} \;
    fi
    
    # COMMENT: Restore service files with security validation
    log "INFO" "Restoring service files"
    if [[ -d "$temp_restore_dir/services" ]]; then
        if ! cp -r "$temp_restore_dir/services"/* "$DOCKER_DIR/"; then
            error_exit "restore_backups" "Service restoration failed"
        fi
        
        # COMMENT: Set secure permissions
        find "$DOCKBACK_DIR" -type f -name "docker-compose.yml" -exec chmod 640 {} \;
        find "$DOCKBACK_DIR" -type f -name ".env" -exec chmod 600 {} \;
        find "$DOCKBACK_DIR" -type d -exec chmod 750 {} \;
    fi
    
    # COMMENT: Cleanup temporary directory
    rm -rf "$temp_restore_dir"
    
    log "SUCCESS" "Backup restoration completed"
}

# COMMENT: Production service restart with health validation
restart_services() {
    local rollback_timestamp="$1"
    log "INFO" "Restarting services for rollback: $rollback_timestamp"
    
    # COMMENT: Read rollback metadata for service information
    local rollback_metadata
    rollback_metadata=$(python3 -c "
import json
import sys
try:
    with open('$ROLLBACK_DIR/rollback-point-$rollback_timestamp.json', 'r') as f:
        data = json.load(f)
        services = data['rollback_point']['deployment_state']['enabled_services']
        print(' '.join(services))
except Exception as e:
    print(f'ERROR: {e}', file=sys.stderr)
    sys.exit(1)
")
    
    if [[ "$rollback_metadata" == ERROR:* ]]; then
        error_exit "restart_services" "Failed to read rollback metadata: $rollback_metadata"
    fi
    
    # COMMENT: Start services in dependency order
    local services=($rollback_metadata)
    for service in "${services[@]}"; do
        local service_dir="$DOCKER_DIR/$service"
        
        if [[ -d "$service_dir" ]] && [[ -f "$service_dir/docker-compose.yml" ]]; then
            log "INFO" "Starting service: $service"
            
            if cd "$service_dir" && docker-compose up -d; then
                log "SUCCESS" "Service started: $service"
                
                # COMMENT: Wait for service to be ready
                sleep 10
            else
                log "WARNING" "Service start failed: $service (continuing with rollback)"
            fi
        fi
    done
    
    log "SUCCESS" "Service restart operations completed"
}

# COMMENT: Production health validation with comprehensive checks
validate_rollback_health() {
    local rollback_timestamp="$1"
    log "INFO" "Validating rollback health for timestamp: $rollback_timestamp"
    
    # COMMENT: Wait for services to stabilize
    log "INFO" "Waiting for services to stabilize"
    sleep 30
    
    # COMMENT: Check Docker service status
    log "INFO" "Checking Docker service status"
    if ! docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -q "Up"; then
        error_exit "validate_rollback_health" "No Docker services are running"
    fi
    
    # COMMENT: Validate critical service ports
    local critical_ports=(80 443 8080 9000 5432 6379)
    for port in "${critical_ports[@]}"; do
        if ! netstat -tlnp 2>/dev/null | grep -q ":$port "; then
            log "WARNING" "Critical port $port is not listening"
        else
            log "INFO" "Critical port $port is listening"
        fi
    done
    
    # COMMENT: Test SSL certificate
    log "INFO" "Testing SSL certificate"
    if command -v openssl >/dev/null 2>&1; then
        if openssl s_client -connect localhost:443 -servername localhost </dev/null 2>/dev/null | grep -q "Verify return code: 0"; then
            log "SUCCESS" "SSL certificate validation passed"
        else
            log "WARNING" "SSL certificate validation failed"
        fi
    fi
    
    # COMMENT: Test basic connectivity
    log "INFO" "Testing basic connectivity"
    if ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        log "SUCCESS" "Basic connectivity test passed"
    else
        log "WARNING" "Basic connectivity test failed"
    fi
    
    log "SUCCESS" "Rollback health validation completed"
}

# COMMENT: Production error notification with security
send_error_notification() {
    local function_name="$1"
    local error_message="$2"
    
    # COMMENT: Read notification configuration from rollback metadata
    if [[ -f "$ROLLBACK_DIR/rollback-point-$1.json" ]]; then
        local webhook_url
        webhook_url=$(python3 -c "
import json
import sys
try:
    with open('$ROLLBACK_DIR/rollback-point-$1.json', 'r') as f:
        data = json.load(f)
        webhook = data['rollback_point']['notification_settings']['webhook_url']
        print(webhook if webhook else '')
except:
    print('')
")
        
        if [[ -n "$webhook_url" ]]; then
            log "INFO" "Sending error notification to webhook"
            # COMMENT: Send notification (implementation depends on webhook service)
            curl -s -X POST "$webhook_url" \
                -H "Content-Type: application/json" \
                -d "{\"text\":\"Rollback failed in $function_name: $error_message\"}" \
                --max-time 30 >/dev/null 2>&1 || true
        fi
    fi
}

# COMMENT: Production rollback completion notification
send_success_notification() {
    local rollback_timestamp="$1"
    
    # COMMENT: Read notification configuration from rollback metadata
    if [[ -f "$ROLLBACK_DIR/rollback-point-$rollback_timestamp.json" ]]; then
        local webhook_url
        webhook_url=$(python3 -c "
import json
import sys
try:
    with open('$ROLLBACK_DIR/rollback-point-$rollback_timestamp.json', 'r') as f:
        data = json.load(f)
        webhook = data['rollback_point']['notification_settings']['webhook_url']
        print(webhook if webhook else '')
except:
    print('')
")
        
        if [[ -n "$webhook_url" ]]; then
            log "INFO" "Sending success notification to webhook"
            # COMMENT: Send notification (implementation depends on webhook service)
            curl -s -X POST "$webhook_url" \
                -H "Content-Type: application/json" \
                -d "{\"text\":\"Rollback completed successfully to timestamp: $rollback_timestamp\"}" \
                --max-time 30 >/dev/null 2>&1 || true
        fi
    fi
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: $0 <rollback_timestamp>

Production Rollback Execution Script v$SCRIPT_VERSION

DESCRIPTION:
    This script executes a comprehensive rollback to a previous deployment state.
    It includes security validation, backup integrity checks, and health validation.

PARAMETERS:
    rollback_timestamp    Unix timestamp of the rollback point to restore

REQUIREMENTS:
    - Must be run as root or with sudo privileges
    - Docker service must be running
    - Valid rollback point must exist
    - Sufficient disk space for restoration

SECURITY FEATURES:
    - Comprehensive input validation
    - Secure file permissions
    - Backup integrity verification
    - Health validation checks
    - Audit logging

EXAMPLES:
    $0 1640995200                    # Rollback to specific timestamp
    sudo $0 1640995200               # With sudo privileges

ROLLBACK PROCESS:
    1. Validate prerequisites and backup integrity
    2. Stop all affected services
    3. Restore configuration and service files
    4. Restart services in dependency order
    5. Validate system health and connectivity
    6. Send completion notification

ERROR HANDLING:
    - Comprehensive error checking at each step
    - Automatic cleanup on failure
    - Detailed error logging
    - Error notification support

LOGGING:
    All operations are logged to: $LOG_FILE

EOF
}

# COMMENT: Production main rollback function with comprehensive error handling
main() {
    local rollback_timestamp="$1"
    
    # COMMENT: Acquire rollback lock for concurrency control
    acquire_rollback_lock
    
    # COMMENT: Create rollback log entry
    log "INFO" "Starting production rollback to timestamp: $rollback_timestamp"
    log "INFO" "Rollback environment: $ROLLBACK_ENVIRONMENT"
    log "INFO" "Rollback user: $ROLLBACK_USER"
    
    # COMMENT: Execute rollback with comprehensive validation
    check_prerequisites "$rollback_timestamp"
    validate_backup_integrity "$rollback_timestamp"
    stop_services "$rollback_timestamp"
    restore_backups "$rollback_timestamp"
    restart_services "$rollback_timestamp"
    validate_rollback_health "$rollback_timestamp"
    
    # COMMENT: Send success notification
    send_success_notification "$rollback_timestamp"
    
    # COMMENT: Log rollback completion
    log "SUCCESS" "Production rollback completed successfully to timestamp: $rollback_timestamp"
    
    # COMMENT: Release rollback lock
    release_rollback_lock
    
    # COMMENT: Display completion summary
    cat << EOF

========================================
PRODUCTION ROLLBACK COMPLETED SUCCESSFULLY
========================================

Rollback Target: $rollback_timestamp
Completion Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $ROLLBACK_ENVIRONMENT
User: $ROLLBACK_USER

Rollback Status: COMPLETED
Services Restored: All requested services
Health Validation: PASSED
SSL Certificate: VALIDATED

Rollback Log: $LOG_FILE
Rollback Directory: $ROLLBACK_DIR

========================================

EOF
}

# COMMENT: Production argument validation and execution
if [[ $# -eq 0 ]]; then
    show_usage
    exit 1
fi

if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    show_usage
    exit 0
fi

# COMMENT: Execute main rollback function
main "$@" 