#!/bin/bash
# Health Monitoring Script
# Monitors service health and performs self-healing actions

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="${SCRIPT_DIR}/health-monitor.log"
CONFIG_FILE="${SCRIPT_DIR}/endpoints.yml"
HEALING_RULES_FILE="${SCRIPT_DIR}/healing-rules.yml"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR: $1"
    exit 1
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   error_exit "This script must be run as root"
fi

# Load configuration
if [[ ! -f "$CONFIG_FILE" ]]; then
    error_exit "Configuration file not found: $CONFIG_FILE"
fi

# Parse YAML configuration (simplified)
parse_yaml() {
    local prefix=$2
    local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
    awk -F$fs '{
        indent = length($1)/2;
        vname[indent] = $2;
        for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
        }
    }'
}

# Check service health
check_service_health() {
    local service_name=$1
    local url=$2
    local method=$3
    local expected_status=$4
    local timeout=$5
    
    log "Checking health of $service_name..."
    
    if [[ "$method" == "TCP" ]]; then
        # TCP connection check
        local host=$(echo "$url" | cut -d: -f1)
        local port=$(echo "$url" | cut -d: -f2)
        
        if timeout "$timeout" bash -c "</dev/tcp/$host/$port" 2>/dev/null; then
            log "✓ $service_name is healthy (TCP port $port)"
            return 0
        else
            log "✗ $service_name is unhealthy (TCP port $port)"
            return 1
        fi
    else
        # HTTP health check
        if curl -f -s --max-time "$timeout" "$url" >/dev/null 2>&1; then
            log "✓ $service_name is healthy (HTTP)"
            return 0
        else
            log "✗ $service_name is unhealthy (HTTP)"
            return 1
        fi
    fi
}

# Perform self-healing action
perform_healing() {
    local service_name=$1
    local action=$2
    
    log "Performing healing action for $service_name: $action"
    
    case "$action" in
        "restart")
            docker restart "$service_name" || log "Failed to restart $service_name"
            ;;
        "cleanup_memory")
            sync
            echo 3 > /proc/sys/vm/drop_caches
            log "Memory cleanup completed"
            ;;
        "cleanup_disk")
            docker system prune -f
            find {{ logs_dir }} -name '*.log' -mtime +7 -delete
            log "Disk cleanup completed"
            ;;
        *)
            log "Unknown healing action: $action"
            ;;
    esac
}

# Check system resources
check_system_resources() {
    log "Checking system resources..."
    
    # CPU usage
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    if (( $(echo "$cpu_usage > 90" | bc -l) )); then
        log "⚠ High CPU usage: ${cpu_usage}%"
        perform_healing "system" "cleanup_memory"
    fi
    
    # Memory usage
    memory_usage=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100.0}')
    if (( $(echo "$memory_usage > 95" | bc -l) )); then
        log "⚠ High memory usage: ${memory_usage}%"
        perform_healing "system" "cleanup_memory"
    fi
    
    # Disk usage
    disk_usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
    if (( disk_usage > 90 )); then
        log "⚠ High disk usage: ${disk_usage}%"
        perform_healing "system" "cleanup_disk"
    fi
}

# Check Docker containers
check_docker_containers() {
    log "Checking Docker containers..."
    
    # Check for failed containers
    failed_containers=$(docker ps -a --filter "status=exited" --format "{{.Names}}")
    if [[ -n "$failed_containers" ]]; then
        log "⚠ Failed containers detected: $failed_containers"
        
        # Restart failed containers
        for container in $failed_containers; do
            log "Restarting failed container: $container"
            docker restart "$container" || log "Failed to restart $container"
        done
    fi
    
    # Check container health
    unhealthy_containers=$(docker ps --filter "health=unhealthy" --format "{{.Names}}")
    if [[ -n "$unhealthy_containers" ]]; then
        log "⚠ Unhealthy containers detected: $unhealthy_containers"
        
        # Restart unhealthy containers
        for container in $unhealthy_containers; do
            log "Restarting unhealthy container: $container"
            docker restart "$container" || log "Failed to restart $container"
        done
    fi
}

# Check network connectivity
check_network() {
    log "Checking network connectivity..."
    
    if ! ping -c 3 8.8.8.8 >/dev/null 2>&1; then
        log "⚠ Network connectivity failed"
        systemctl restart networking || log "Failed to restart networking"
    fi
    
    if ! nslookup google.com >/dev/null 2>&1; then
        log "⚠ DNS resolution failed"
        systemctl restart systemd-resolved || log "Failed to restart systemd-resolved"
    fi
}

# Main health check function
main_health_check() {
    log "Starting health monitoring..."
    
    # Check system resources
    check_system_resources
    
    # Check Docker containers
    check_docker_containers
    
    # Check network connectivity
    check_network
    
    # Check specific services (simplified - would normally parse YAML)
    services=(
        "traefik:http://localhost:8080/api/health:GET:200:10"
        "grafana:http://localhost:3000/api/health:GET:200:10"
        "prometheus:http://localhost:9090/-/healthy:GET:200:10"
        "postgresql:localhost:5432:TCP:connected:5"
        "redis:localhost:6379:TCP:connected:5"
    )
    
    for service_config in "${services[@]}"; do
        IFS=':' read -r service_name url method expected_status timeout <<< "$service_config"
        
        if ! check_service_health "$service_name" "$url" "$method" "$expected_status" "$timeout"; then
            log "⚠ Service $service_name failed health check"
            perform_healing "$service_name" "restart"
        fi
    done
    
    log "Health monitoring completed"
}

# Run main function
main_health_check "$@" 