#!/bin/bash
# Paperless-ngx Backup Script
# Generated by Ansible - Do not edit manually

set -e

# Configuration
SERVICE_NAME="paperless-ngx"
CONTAINER_NAME="{{ paperless_ngx_container_name }}"
BACKUP_DIR="{{ paperless_ngx_backup_dir }}"
DATA_DIR="{{ data_dir }}/paperless-ngx"
DOCKER_DIR="{{ docker_dir }}/paperless-ngx"
CONFIG_DIR="{{ config_dir }}/paperless-ngx"
LOGS_DIR="{{ logs_dir }}/paperless-ngx"
LOG_FILE="{{ paperless_ngx_backup_log_file }}"
MAX_LOG_SIZE="{{ paperless_ngx_backup_max_log_size | default('10M') }}"
NOTIFICATION_ENABLED="{{ paperless_ngx_backup_notifications_enabled | default(true) | lower }}"

# Database configuration
DB_TYPE="{{ paperless_ngx_database_type }}"
DB_HOST="{{ paperless_ngx_database_host }}"
DB_PORT="{{ paperless_ngx_database_port }}"
DB_NAME="{{ paperless_ngx_database_name }}"
DB_USER="{{ paperless_ngx_database_user }}"
DB_PASS="{{ vault_paperless_database_password | default('') }}"

# Backup settings
BACKUP_RETENTION="{{ paperless_ngx_backup_retention_days | default(7) }}"
BACKUP_COMPRESSION="{{ paperless_ngx_backup_compression | default(true) | lower }}"
BACKUP_INCLUDE_MEDIA="{{ paperless_ngx_backup_include_media | default(true) | lower }}"
BACKUP_INCLUDE_DATABASE="{{ paperless_ngx_backup_include_database | default(true) | lower }}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Error handling
error_exit() {
    log "${RED}ERROR: $1${NC}"
    exit 1
}

# Check if backup directory exists
check_backup_dir() {
    if [ ! -d "$BACKUP_DIR" ]; then
        log "${YELLOW}Creating backup directory: $BACKUP_DIR${NC}"
        mkdir -p "$BACKUP_DIR"
    fi
}

# Create timestamp for backup
get_timestamp() {
    date +"%Y%m%d_%H%M%S"
}

# Create backup filename
get_backup_filename() {
    local type=$1
    local timestamp=$(get_timestamp)
    echo "${SERVICE_NAME}_${type}_${timestamp}.tar.gz"
}

# Backup database
backup_database() {
    if [ "$BACKUP_INCLUDE_DATABASE" != "true" ]; then
        log "${YELLOW}Skipping database backup (disabled)${NC}"
        return 0
    fi

    log "${BLUE}Starting database backup...${NC}"
    
    local timestamp=$(get_timestamp)
    local db_backup_file="$BACKUP_DIR/database/${SERVICE_NAME}_db_${timestamp}.sql"
    
    # Create database backup directory
    mkdir -p "$BACKUP_DIR/database"
    
    if [ "$DB_TYPE" = "postgresql" ]; then
        # PostgreSQL backup
        if docker exec $CONTAINER_NAME pg_dump -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME > "$db_backup_file" 2>/dev/null; then
            log "${GREEN}✓ Database backup completed: $db_backup_file${NC}"
            
            # Compress if enabled
            if [ "$BACKUP_COMPRESSION" = "true" ]; then
                gzip "$db_backup_file"
                log "${GREEN}✓ Database backup compressed${NC}"
            fi
        else
            error_exit "Database backup failed"
        fi
    elif [ "$DB_TYPE" = "sqlite" ]; then
        # SQLite backup
        local sqlite_file="$DATA_DIR/db.sqlite3"
        if [ -f "$sqlite_file" ]; then
            cp "$sqlite_file" "$db_backup_file"
            log "${GREEN}✓ SQLite database backup completed: $db_backup_file${NC}"
            
            # Compress if enabled
            if [ "$BACKUP_COMPRESSION" = "true" ]; then
                gzip "$db_backup_file"
                log "${GREEN}✓ SQLite database backup compressed${NC}"
            fi
        else
            error_exit "SQLite database file not found: $sqlite_file"
        fi
    else
        error_exit "Unsupported database type: $DB_TYPE"
    fi
}

# Backup media files
backup_media() {
    if [ "$BACKUP_INCLUDE_MEDIA" != "true" ]; then
        log "${YELLOW}Skipping media backup (disabled)${NC}"
        return 0
    fi

    log "${BLUE}Starting media backup...${NC}"
    
    local timestamp=$(get_timestamp)
    local media_backup_file="$BACKUP_DIR/media/${SERVICE_NAME}_media_${timestamp}.tar.gz"
    
    # Create media backup directory
    mkdir -p "$BACKUP_DIR/media"
    
    # Create media backup
    if tar -czf "$media_backup_file" -C "$DATA_DIR" documents thumbnails archive originals 2>/dev/null; then
        log "${GREEN}✓ Media backup completed: $media_backup_file${NC}"
    else
        error_exit "Media backup failed"
    fi
}

# Backup configuration
backup_config() {
    log "${BLUE}Starting configuration backup...${NC}"
    
    local timestamp=$(get_timestamp)
    local config_backup_file="$BACKUP_DIR/config/${SERVICE_NAME}_config_${timestamp}.tar.gz"
    
    # Create config backup directory
    mkdir -p "$BACKUP_DIR/config"
    
    # Create configuration backup
    if tar -czf "$config_backup_file" -C "$DOCKER_DIR" .env docker-compose.yml 2>/dev/null; then
        log "${GREEN}✓ Configuration backup completed: $config_backup_file${NC}"
    else
        error_exit "Configuration backup failed"
    fi
}

# Backup logs
backup_logs() {
    log "${BLUE}Starting logs backup...${NC}"
    
    local timestamp=$(get_timestamp)
    local logs_backup_file="$BACKUP_DIR/logs/${SERVICE_NAME}_logs_${timestamp}.tar.gz"
    
    # Create logs backup directory
    mkdir -p "$BACKUP_DIR/logs"
    
    # Create logs backup
    if tar -czf "$logs_backup_file" -C "$LOGS_DIR" . 2>/dev/null; then
        log "${GREEN}✓ Logs backup completed: $logs_backup_file${NC}"
    else
        error_exit "Logs backup failed"
    fi
}

# Create full backup
create_full_backup() {
    log "${BLUE}Creating full backup...${NC}"
    
    local timestamp=$(get_timestamp)
    local full_backup_file="$BACKUP_DIR/${SERVICE_NAME}_full_${timestamp}.tar.gz"
    
    # Create temporary directory for backup
    local temp_dir=$(mktemp -d)
    
    # Copy all components to temp directory
    mkdir -p "$temp_dir/database" "$temp_dir/media" "$temp_dir/config" "$temp_dir/logs"
    
    # Copy database backup
    if [ "$BACKUP_INCLUDE_DATABASE" = "true" ]; then
        cp "$BACKUP_DIR/database"/* "$temp_dir/database/" 2>/dev/null || true
    fi
    
    # Copy media backup
    if [ "$BACKUP_INCLUDE_MEDIA" = "true" ]; then
        cp "$BACKUP_DIR/media"/* "$temp_dir/media/" 2>/dev/null || true
    fi
    
    # Copy config backup
    cp "$BACKUP_DIR/config"/* "$temp_dir/config/" 2>/dev/null || true
    
    # Copy logs backup
    cp "$BACKUP_DIR/logs"/* "$temp_dir/logs/" 2>/dev/null || true
    
    # Create full backup archive
    if tar -czf "$full_backup_file" -C "$temp_dir" . 2>/dev/null; then
        log "${GREEN}✓ Full backup completed: $full_backup_file${NC}"
    else
        error_exit "Full backup failed"
    fi
    
    # Clean up temp directory
    rm -rf "$temp_dir"
}

# Cleanup old backups
cleanup_old_backups() {
    log "${BLUE}Cleaning up old backups...${NC}"
    
    # Remove backups older than retention period
    find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$BACKUP_RETENTION -delete 2>/dev/null || true
    find "$BACKUP_DIR" -name "*.sql" -mtime +$BACKUP_RETENTION -delete 2>/dev/null || true
    find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$BACKUP_RETENTION -delete 2>/dev/null || true
    
    log "${GREEN}✓ Old backups cleaned up${NC}"
}

# Verify backup
verify_backup() {
    log "${BLUE}Verifying backup...${NC}"
    
    local backup_file="$1"
    
    if [ -f "$backup_file" ]; then
        # Check if tar file is valid
        if tar -tzf "$backup_file" > /dev/null 2>&1; then
            log "${GREEN}✓ Backup verification passed: $backup_file${NC}"
            return 0
        else
            log "${RED}✗ Backup verification failed: $backup_file${NC}"
            return 1
        fi
    else
        log "${RED}✗ Backup file not found: $backup_file${NC}"
        return 1
    fi
}

# Main backup function
main() {
    local backup_type="${1:-daily}"
    
    log "${BLUE}Starting $backup_type backup for $SERVICE_NAME...${NC}"
    
    # Check if container is running
    if ! docker ps --format "table {{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        error_exit "Container $CONTAINER_NAME is not running"
    fi
    
    # Check backup directory
    check_backup_dir
    
    # Create backup directories
    mkdir -p "$BACKUP_DIR/database" "$BACKUP_DIR/media" "$BACKUP_DIR/config" "$BACKUP_DIR/logs"
    
    # Perform backups
    backup_database
    backup_media
    backup_config
    backup_logs
    
    # Create full backup for weekly/monthly
    if [ "$backup_type" = "weekly" ] || [ "$backup_type" = "monthly" ]; then
        create_full_backup
    fi
    
    # Cleanup old backups
    cleanup_old_backups
    
    log "${GREEN}✓ $backup_type backup completed successfully${NC}"
}

# Test function
test_backup() {
    log "${BLUE}Testing backup functionality...${NC}"
    
    # Check if all required directories exist
    local required_dirs=("$BACKUP_DIR" "$DATA_DIR" "$DOCKER_DIR" "$CONFIG_DIR" "$LOGS_DIR")
    
    for dir in "${required_dirs[@]}"; do
        if [ -d "$dir" ]; then
            log "${GREEN}✓ Directory exists: $dir${NC}"
        else
            log "${RED}✗ Directory missing: $dir${NC}"
            return 1
        fi
    done
    
    # Check if container is running
    if docker ps --format "table {{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
        log "${GREEN}✓ Container is running: $CONTAINER_NAME${NC}"
    else
        log "${RED}✗ Container is not running: $CONTAINER_NAME${NC}"
        return 1
    fi
    
    # Check database connectivity
    if [ "$DB_TYPE" = "postgresql" ]; then
        if docker exec $CONTAINER_NAME pg_isready -h $DB_HOST -p $DB_PORT -U $DB_USER > /dev/null 2>&1; then
            log "${GREEN}✓ Database connectivity OK${NC}"
        else
            log "${RED}✗ Database connectivity failed${NC}"
            return 1
        fi
    fi
    
    log "${GREEN}✓ Backup test completed successfully${NC}"
}

# Handle command line arguments
case "${1:-}" in
    "daily")
        main "daily"
        ;;
    "weekly")
        main "weekly"
        ;;
    "monthly")
        main "monthly"
        ;;
    "test")
        test_backup
        ;;
    *)
        echo "Usage: $0 [daily|weekly|monthly|test]"
        echo "  daily   - Create daily backup"
        echo "  weekly  - Create weekly backup (includes full backup)"
        echo "  monthly - Create monthly backup (includes full backup)"
        echo "  test    - Test backup functionality"
        exit 1
        ;;
esac 