#!/usr/bin/env python3
"""
Authentik Configuration Automation Script
Handles dynamic configuration generation and integration setup
"""

import os
import sys
import json
import yaml
import requests
import argparse
import logging
import re
import html
import ssl
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ logs_dir }}/security/authentik/authentik_automation.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class InputValidator:
    """Input validation and sanitization utilities for Authentik"""
    
    @staticmethod
    def validate_url(url: str) -> bool:
        """Validate URL format and security"""
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            return all([parsed.scheme, parsed.netloc])
        except Exception:
            return False
    
    @staticmethod
    def sanitize_string(value: str) -> str:
        """Sanitize string input"""
        if not isinstance(value, str):
            raise ValueError("Input must be a string")
        return html.escape(value.strip())
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """Validate email format"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, email))
    
    @staticmethod
    def validate_username(username: str) -> bool:
        """Validate username format"""
        pattern = r'^[a-zA-Z0-9_-]{3,20}$'
        return bool(re.match(pattern, username))
    
    @staticmethod
    def validate_password_strength(password: str) -> bool:
        """Validate password strength"""
        if len(password) < 8:
            return False
        if not re.search(r'[A-Z]', password):
            return False
        if not re.search(r'[a-z]', password):
            return False
        if not re.search(r'\d', password):
            return False
        return True
    
    @staticmethod
    def validate_group_name(name: str) -> bool:
        """Validate group name format"""
        if not name or len(name) > 50:
            return False
        pattern = r'^[a-zA-Z0-9\s_-]+$'
        return bool(re.match(pattern, name))

@dataclass
class AuthentikConfig:
    """Authentik configuration structure"""
    api_url: str
    admin_user: str
    admin_password: str
    token: str
    domain: str
    port: int

class AuthentikAutomation:
    """Authentik configuration automation"""
    
    def __init__(self, config_path: str = None):
        self.config_path = config_path or "automation_config.yml"
        self.config = self.load_config()
        self.authentik_url = "http://{{ ansible_default_ipv4.address }}:{{ authentik_port }}"
        self.admin_user = "{{ vault_authentik_admin_user | default('admin') }}"
        self.admin_password: "{{ vault_security_admin_password | password_hash("bcrypt") }}"{{ vault_authentik_api_token | default('') }}"
        self.session = self.create_session()
        
    def load_config(self) -> Dict[str, Any]:
        """Load configuration from YAML file"""
        try:
            with open(self.config_path, 'r') as f:
                config = yaml.safe_load(f)
            logger.info(f"Loaded configuration from {self.config_path}")
            return config
        except FileNotFoundError:
            logger.error(f"Configuration file {self.config_path} not found")
            return {}
        except yaml.YAMLError as e:
            logger.error(f"Error parsing configuration file: {e}")
            return {}
    
    def create_session(self) -> requests.Session:
        """Create requests session with authentication"""
        session = requests.Session()
        # SECURITY FIX: Enable SSL verification
        session.verify = True
        session.timeout = 30
        
        # Add certificate validation for enhanced security
        if hasattr(ssl, 'create_default_context'):
            context = ssl.create_default_context()
            context.check_hostname = True
            context.verify_mode = ssl.CERT_REQUIRED
            session.verify = context
        
        if self.api_token:
            session.headers.update({
                'Authorization': f'Bearer {self.api_token}',
                'Content-Type': 'application/json'
            })
        else:
            session.auth = (self.admin_user, self.admin_password)
            session.headers.update({'Content-Type': 'application/json'})
        
        return session
    
    def test_connection(self) -> bool:
        """Test Authentik API connection"""
        try:
            response = self.session.get(f"{self.authentik_url}/api/v3/core/applications/")
            if response.status_code in [200, 302, 401]:
                logger.info("Authentik API connection successful")
                return True
            else:
                logger.error(f"Authentik API connection failed: {response.status_code}")
                return False
        except Exception as e:
            logger.error(f"Error connecting to Authentik API: {e}")
            return False
    
    def get_auth_token(self) -> Optional[str]:
        """Get authentication token"""
        try:
            auth_data = {
                'username': self.admin_user,
                'password': self.admin_password
            }
            
            response = self.session.post(
                f"{self.authentik_url}/api/v3/core/tokens/",
                json=auth_data
            )
            
            if response.status_code == 200:
                token_data = response.json()
                return token_data.get('key')
            else:
                logger.error(f"Failed to get auth token: {response.status_code}")
                return None
                
        except Exception as e:
            logger.error(f"Error getting auth token: {e}")
            return None
    
    def create_group(self, group_config: Dict[str, Any]) -> bool:
        """Create a group in Authentik with input validation"""
        try:
            # SECURITY FIX: Validate and sanitize inputs
            if 'name' not in group_config:
                raise ValueError("Group name is required")
            
            group_name = group_config['name']
            if not InputValidator.validate_group_name(group_name):
                raise ValueError(f"Invalid group name format: {group_name}")
            
            group_name = InputValidator.sanitize_string(group_name)
            description = InputValidator.sanitize_string(group_config.get('description', ''))
            
            group_data = {
                'name': group_name,
                'description': description,
                'is_superuser': bool(group_config.get('is_superuser', False)),
                'parent': InputValidator.sanitize_string(group_config.get('parent', ''))
            }
            
            response = self.session.post(
                f"{self.authentik_url}/api/v3/core/groups/",
                json=group_data
            )
            
            if response.status_code == 201:
                logger.info(f"Created group: {group_name}")
                return True
            elif response.status_code == 400:
                logger.warning(f"Group {group_name} may already exist")
                return True
            else:
                logger.error(f"Failed to create group {group_name}: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Error creating group {group_config.get('name', 'unknown')}: {e}")
            return False
    
    def create_user(self, user_config: Dict[str, Any]) -> bool:
        """Create a user in Authentik with input validation"""
        try:
            # SECURITY FIX: Validate and sanitize inputs
            if 'username' not in user_config:
                raise ValueError("Username is required")
            
            username = user_config['username']
            if not InputValidator.validate_username(username):
                raise ValueError(f"Invalid username format: {username}")
            
            username = InputValidator.sanitize_string(username)
            
            if 'email' not in user_config:
                raise ValueError("Email is required")
            
            email = user_config['email']
            if not InputValidator.validate_email(email):
                raise ValueError(f"Invalid email format: {email}")
            
            email = InputValidator.sanitize_string(email)
            name = InputValidator.sanitize_string(user_config.get('name', username))
            
            # Validate password if provided
            if 'password' in user_config:
                password: "{{ vault_security_admin_password | password_hash("bcrypt") }}"Password for user {username} does not meet strength requirements")
            
            user_data = {
                'username': username,
                'email': email,
                'name': name,
                'is_active': bool(user_config.get('is_active', True)),
                'is_superuser': bool(user_config.get('is_superuser', False)),
                'type': InputValidator.sanitize_string(user_config.get('type', 'internal')),
                'path': InputValidator.sanitize_string(user_config.get('path', 'users'))
            }
            
            response = self.session.post(
                f"{self.authentik_url}/api/v3/core/users/",
                json=user_data
            )
            
            if response.status_code == 201:
                logger.info(f"Created user: {username}")
                
                # Set password if provided
                if 'password' in user_config:
                    self.set_user_password(username, user_config['password'])
                
                return True
            elif response.status_code == 400:
                logger.warning(f"User {username} may already exist")
                return True
            else:
                logger.error(f"Failed to create user {username}: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Error creating user {user_config.get('username', 'unknown')}: {e}")
            return False
    
    def set_user_password(self, username: str, password: str) -> bool:
        """Set user password with validation"""
        try:
            # Validate inputs
            if not InputValidator.validate_username(username):
                raise ValueError(f"Invalid username format: {username}")
            
            if not InputValidator.validate_password_strength(password):
                logger.warning(f"Password for user {username} does not meet strength requirements")
            
            username = InputValidator.sanitize_string(username)
            
            # First get user ID
            response = self.session.get(f"{self.authentik_url}/api/v3/core/users/?username={username}")
            if response.status_code != 200:
                logger.error(f"Failed to get user {username}")
                return False
            
            users = response.json()['results']
            if not users:
                logger.error(f"User {username} not found")
                return False
            
            user_id = users[0]['pk']
            
            # Set password
            password_data = {
                'password': password
            }
            
            response = self.session.partial_update(
                f"{self.authentik_url}/api/v3/core/users/{user_id}/",
                json=password_data
            )
            
            if response.status_code == 200:
                logger.info(f"Set password for user: {username}")
                return True
            else:
                logger.error(f"Failed to set password for user {username}: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Error setting password for user {username}: {e}")
            return False
    
    def create_policy(self, policy_config: Dict[str, Any]) -> bool:
        """Create a policy in Authentik"""
        try:
            policy_data = {
                'name': policy_config['name'],
                'type': policy_config['type'],
                'expression': policy_config['expression'],
                'execution_logging': policy_config.get('execution_logging', False)
            }
            
            response = self.session.post(
                f"{self.authentik_url}/api/v3/policies/user/",
                json=policy_data
            )
            
            if response.status_code == 201:
                logger.info(f"Created policy: {policy_config['name']}")
                return True
            elif response.status_code == 400:
                logger.warning(f"Policy {policy_config['name']} may already exist")
                return True
            else:
                logger.error(f"Failed to create policy {policy_config['name']}: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Error creating policy {policy_config['name']}: {e}")
            return False
    
    def configure_monitoring(self) -> bool:
        """Configure monitoring integration"""
        try:
            monitoring_config = self.config.get('monitoring', {})
            if not monitoring_config.get('enabled', False):
                logger.info("Monitoring integration disabled")
                return True
            
            # Configure Prometheus metrics
            if monitoring_config.get('prometheus', {}).get('enabled', False):
                logger.info("Prometheus metrics already enabled via configuration")
            
            # Configure health checks
            if monitoring_config.get('health_checks', {}).get('enabled', False):
                logger.info("Health checks already enabled via configuration")
            
            logger.info("Monitoring integration configured")
            return True
            
        except Exception as e:
            logger.error(f"Error configuring monitoring integration: {e}")
            return False
    
    def configure_traefik(self) -> bool:
        """Configure Traefik integration"""
        try:
            traefik_config = self.config.get('traefik', {})
            if not traefik_config.get('enabled', False):
                logger.info("Traefik integration disabled")
                return True
            
            # Configure forward authentication
            if traefik_config.get('forward_auth', {}).get('enabled', False):
                logger.info("Forward authentication already enabled via configuration")
            
            # Configure SSL
            if traefik_config.get('ssl', {}).get('enabled', False):
                logger.info("SSL already enabled via configuration")
            
            logger.info("Traefik integration configured")
            return True
            
        except Exception as e:
            logger.error(f"Error configuring Traefik integration: {e}")
            return False
    
    def configure_backup(self) -> bool:
        """Configure backup integration"""
        try:
            backup_config = self.config.get('backup', {})
            if not backup_config.get('enabled', False):
                logger.info("Backup integration disabled")
                return True
            
            # Database backup configuration
            if backup_config.get('database', {}).get('enabled', False):
                logger.info("Database backup already configured")
            
            # Configuration backup
            if backup_config.get('configuration', {}).get('enabled', False):
                logger.info("Configuration backup already configured")
            
            # Certificate backup
            if backup_config.get('certificates', {}).get('enabled', False):
                logger.info("Certificate backup already configured")
            
            logger.info("Backup integration configured")
            return True
            
        except Exception as e:
            logger.error(f"Error configuring backup integration: {e}")
            return False
    
    def validate_configuration(self) -> bool:
        """Validate generated configuration"""
        try:
            # Test API connectivity
            if not self.test_connection():
                logger.error("Failed to connect to Authentik API")
                return False
            
            # Check if groups exist
            response = self.session.get(f"{self.authentik_url}/api/v3/core/groups/")
            if response.status_code != 200:
                logger.error("Failed to get groups")
                return False
            
            # Check if users exist
            response = self.session.get(f"{self.authentik_url}/api/v3/core/users/")
            if response.status_code != 200:
                logger.error("Failed to get users")
                return False
            
            # Check if policies exist
            response = self.session.get(f"{self.authentik_url}/api/v3/policies/user/")
            if response.status_code != 200:
                logger.error("Failed to get policies")
                return False
            
            logger.info("Configuration validation successful")
            return True
            
        except Exception as e:
            logger.error(f"Configuration validation failed: {e}")
            return False
    
    def run_automation(self) -> bool:
        """Run the complete automation process"""
        logger.info("Starting Authentik configuration automation")
        
        try:
            # Test connection
            if not self.test_connection():
                logger.error("Cannot connect to Authentik API")
                return False
            
            # Create groups
            groups_config = self.config.get('groups', {}).get('default_groups', [])
            for group_config in groups_config:
                if not self.create_group(group_config):
                    logger.warning(f"Failed to create group {group_config['name']}")
            
            # Create users
            users_config = self.config.get('users', {})
            
            # Create admin users
            admin_users = users_config.get('admin_users', [])
            for user_config in admin_users:
                if not self.create_user(user_config):
                    logger.warning(f"Failed to create admin user {user_config['username']}")
            
            # Create regular users
            regular_users = users_config.get('regular_users', [])
            for user_config in regular_users:
                if not self.create_user(user_config):
                    logger.warning(f"Failed to create regular user {user_config['username']}")
            
            # Create policies
            policies_config = self.config.get('policies', {}).get('default_policies', [])
            for policy_config in policies_config:
                if not self.create_policy(policy_config):
                    logger.warning(f"Failed to create policy {policy_config['name']}")
            
            # Configure integrations
            if not self.configure_monitoring():
                logger.warning("Monitoring integration configuration failed")
            
            if not self.configure_traefik():
                logger.warning("Traefik integration configuration failed")
            
            if not self.configure_backup():
                logger.warning("Backup integration configuration failed")
            
            # Validate configuration
            if not self.validate_configuration():
                logger.warning("Configuration validation failed")
            
            logger.info("Authentik configuration automation completed successfully")
            return True
            
        except Exception as e:
            logger.error(f"Authentik configuration automation failed: {e}")
            return False

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Authentik Configuration Automation')
    parser.add_argument('--config', '-c', default='automation_config.yml',
                       help='Configuration file path')
    parser.add_argument('--test', action='store_true',
                       help='Run in test mode')
    parser.add_argument('--validate', action='store_true',
                       help='Validate existing configuration')
    
    args = parser.parse_args()
    
    # Initialize automation
    automation = AuthentikAutomation(args.config)
    
    if args.test:
        logger.info("Running in test mode")
        if automation.test_connection():
            print("Authentik API connection successful")
            return 0
        else:
            print("Authentik API connection failed")
            return 1
    
    elif args.validate:
        logger.info("Validating existing configuration")
        success = automation.validate_configuration()
        return 0 if success else 1
    
    else:
        # Run full automation
        success = automation.run_automation()
        return 0 if success else 1

if __name__ == '__main__':
    sys.exit(main()) 