#!/bin/bash
# COMMENT: Production-ready Security Utilities for Ansible Homelab
# COMMENT: Comprehensive security validation, hardening, and monitoring functions
# COMMENT: Generated by: Ansible automation
# COMMENT: Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
# COMMENT: Environment: production

# COMMENT: Production security settings for security utility reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="security_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production security configuration with validation
SECURITY_LEVELS=("low" "medium" "high" "critical")
DEFAULT_SECURITY_LEVEL="high"
SECURITY_SCAN_TIMEOUT=300
SECURITY_VALIDATION_RETRIES=3
SECURITY_LOG_RETENTION_DAYS=90

# COMMENT: Production environment variables with validation
export SECURITY_UTILS_ENVIRONMENT="production"
export SECURITY_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Source logging utilities if available
if [[ -f "$SCRIPT_DIR/logging_utils.sh" ]]; then
    source "$SCRIPT_DIR/logging_utils.sh"
else
    # COMMENT: Fallback logging if utilities not available
    log_info() { echo "[INFO] $1"; }
    log_warning() { echo "[WARNING] $1" >&2; }
    log_error() { echo "[ERROR] $1" >&2; }
    log_success() { echo "[SUCCESS] $1"; }
fi

# COMMENT: Production security level validation with security
validate_security_level() {
    local level="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$level" ]]; then
        log_error "Security level not specified"
        return 1
    fi
    
    # COMMENT: Validate security level
    case "$level" in
        low|medium|high|critical)
            return 0
            ;;
        *)
            log_error "Invalid security level: $level"
            return 1
            ;;
    esac
}

# COMMENT: Production file permission validation with security
validate_file_permissions() {
    local file_path="$1"
    local expected_permissions="${2:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$file_path" ]]; then
        log_error "File path not specified for permission validation"
        return 1
    fi
    
    if [[ ! -e "$file_path" ]]; then
        log_error "File does not exist: $file_path"
        return 1
    fi
    
    # COMMENT: Get current file permissions
    local current_permissions
    current_permissions=$(stat -c "%a" "$file_path" 2>/dev/null || stat -f "%Lp" "$file_path" 2>/dev/null)
    
    if [[ -z "$current_permissions" ]]; then
        log_error "Cannot read file permissions: $file_path"
        return 1
    fi
    
    # COMMENT: Validate against expected permissions if provided
    if [[ -n "$expected_permissions" ]]; then
        if [[ "$current_permissions" != "$expected_permissions" ]]; then
            log_warning "File permissions mismatch: $file_path (current: $current_permissions, expected: $expected_permissions)"
            return 1
        fi
    else
        # COMMENT: Check if permissions are secure by default
        local file_type
        if [[ -d "$file_path" ]]; then
            # COMMENT: Directory should be 750 or more restrictive
            if [[ "$current_permissions" != "7"* ]] && [[ "$current_permissions" != "6"* ]] && [[ "$current_permissions" != "5"* ]]; then
                log_warning "Directory has insecure permissions: $file_path ($current_permissions)"
                return 1
            fi
        else
            # COMMENT: File should be 640 or more restrictive
            if [[ "$current_permissions" != "6"* ]] && [[ "$current_permissions" != "5"* ]] && [[ "$current_permissions" != "4"* ]]; then
                log_warning "File has insecure permissions: $file_path ($current_permissions)"
                return 1
            fi
        fi
    fi
    
    log_info "File permissions validation passed: $file_path ($current_permissions)"
    return 0
}

# COMMENT: Production file ownership validation with security
validate_file_ownership() {
    local file_path="$1"
    local expected_owner="${2:-}"
    local expected_group="${3:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$file_path" ]]; then
        log_error "File path not specified for ownership validation"
        return 1
    fi
    
    if [[ ! -e "$file_path" ]]; then
        log_error "File does not exist: $file_path"
        return 1
    fi
    
    # COMMENT: Get current file ownership
    local current_owner current_group
    current_owner=$(stat -c "%U" "$file_path" 2>/dev/null || stat -f "%Su" "$file_path" 2>/dev/null)
    current_group=$(stat -c "%G" "$file_path" 2>/dev/null || stat -f "%Sg" "$file_path" 2>/dev/null)
    
    if [[ -z "$current_owner" || -z "$current_group" ]]; then
        log_error "Cannot read file ownership: $file_path"
        return 1
    fi
    
    # COMMENT: Validate against expected ownership if provided
    if [[ -n "$expected_owner" && "$current_owner" != "$expected_owner" ]]; then
        log_warning "File owner mismatch: $file_path (current: $current_owner, expected: $expected_owner)"
        return 1
    fi
    
    if [[ -n "$expected_group" && "$current_group" != "$expected_group" ]]; then
        log_warning "File group mismatch: $file_path (current: $current_group, expected: $expected_group)"
        return 1
    fi
    
    # COMMENT: Check for root ownership (security risk)
    if [[ "$current_owner" == "root" ]]; then
        log_warning "File owned by root (security risk): $file_path"
    fi
    
    log_info "File ownership validation passed: $file_path ($current_owner:$current_group)"
    return 0
}

# COMMENT: Production SSL certificate validation with security
validate_ssl_certificate() {
    local hostname="$1"
    local port="${2:-443}"
    local timeout="${3:-30}"
    
    # COMMENT: Input validation for security
    if [[ -z "$hostname" ]]; then
        log_error "Hostname not specified for SSL validation"
        return 1
    fi
    
    # COMMENT: Validate hostname format
    if ! echo "$hostname" | grep -E '^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' >/dev/null; then
        log_error "Invalid hostname format: $hostname"
        return 1
    fi
    
    # COMMENT: Validate port number
    if ! echo "$port" | grep -E '^[0-9]+$' >/dev/null || [[ "$port" -lt 1 || "$port" -gt 65535 ]]; then
        log_error "Invalid port number: $port"
        return 1
    fi
    
    # COMMENT: Check if openssl is available
    if ! command -v openssl >/dev/null 2>&1; then
        log_error "openssl command not available"
        return 1
    fi
    
    # COMMENT: Validate SSL certificate
    log_info "Validating SSL certificate for $hostname:$port"
    
    local cert_info
    if cert_info=$(timeout "$timeout" openssl s_client -connect "$hostname:$port" -servername "$hostname" </dev/null 2>/dev/null | openssl x509 -noout -dates -subject -issuer 2>/dev/null); then
        log_success "SSL certificate validation passed for $hostname:$port"
        
        # COMMENT: Extract and log certificate details
        local not_before not_after subject issuer
        not_before=$(echo "$cert_info" | grep "notBefore" | cut -d= -f2)
        not_after=$(echo "$cert_info" | grep "notAfter" | cut -d= -f2)
        subject=$(echo "$cert_info" | grep "subject" | cut -d= -f2-)
        issuer=$(echo "$cert_info" | grep "issuer" | cut -d= -f2-)
        
        log_info "Certificate details:"
        log_info "  Subject: $subject"
        log_info "  Issuer: $issuer"
        log_info "  Valid from: $not_before"
        log_info "  Valid until: $not_after"
        
        return 0
    else
        log_error "SSL certificate validation failed for $hostname:$port"
        return 1
    fi
}

# COMMENT: Production firewall rule validation with security
validate_firewall_rules() {
    local expected_rules="${1:-}"
    
    # COMMENT: Check if ufw is available
    if ! command -v ufw >/dev/null 2>&1; then
        log_warning "ufw command not available - firewall validation skipped"
        return 0
    fi
    
    # COMMENT: Check firewall status
    local firewall_status
    firewall_status=$(ufw status 2>/dev/null | grep -E "Status: (active|inactive)")
    
    if [[ -z "$firewall_status" ]]; then
        log_error "Cannot determine firewall status"
        return 1
    fi
    
    log_info "Firewall status: $firewall_status"
    
    # COMMENT: Check if firewall is active
    if echo "$firewall_status" | grep -q "Status: active"; then
        log_success "Firewall is active"
        
        # COMMENT: Get current firewall rules
        local current_rules
        current_rules=$(ufw status numbered 2>/dev/null | grep -E "^\[[0-9]+\]" | sed 's/^\[[0-9]\+\] //')
        
        if [[ -n "$current_rules" ]]; then
            log_info "Current firewall rules:"
            echo "$current_rules" | while read -r rule; do
                log_info "  $rule"
            done
        else
            log_warning "No firewall rules found"
        fi
        
        # COMMENT: Validate expected rules if provided
        if [[ -n "$expected_rules" ]]; then
            log_info "Validating expected firewall rules"
            # COMMENT: Implementation would check against expected_rules
        fi
        
        return 0
    else
        log_warning "Firewall is not active"
        return 1
    fi
}

# COMMENT: Production SSH configuration validation with security
validate_ssh_config() {
    local sshd_config_file="${1:-/etc/ssh/sshd_config}"
    
    # COMMENT: Input validation for security
    if [[ -z "$sshd_config_file" ]]; then
        log_error "SSH config file path not specified"
        return 1
    fi
    
    if [[ ! -f "$sshd_config_file" ]]; then
        log_error "SSH config file not found: $sshd_config_file"
        return 1
    fi
    
    # COMMENT: Validate file permissions and ownership
    if ! validate_file_permissions "$sshd_config_file" "600"; then
        log_error "SSH config file has insecure permissions"
        return 1
    fi
    
    if ! validate_file_ownership "$sshd_config_file" "root" "root"; then
        log_error "SSH config file has incorrect ownership"
        return 1
    fi
    
    # COMMENT: Check critical SSH security settings
    log_info "Validating SSH configuration security settings"
    
    local critical_settings=(
        "PasswordAuthentication no"
        "PermitRootLogin no"
        "PubkeyAuthentication yes"
        "Protocol 2"
        "X11Forwarding no"
        "AllowTcpForwarding no"
        "PermitTunnel no"
        "MaxAuthTries 3"
        "LoginGraceTime 30"
    )
    
    local validation_passed=true
    
    for setting in "${critical_settings[@]}"; do
        local key value
        key=$(echo "$setting" | cut -d' ' -f1)
        value=$(echo "$setting" | cut -d' ' -f2-)
        
        local current_value
        current_value=$(grep -E "^$key\\s+" "$sshd_config_file" 2>/dev/null | tail -1 | sed 's/^[^[:space:]]*[[:space:]]*//')
        
        if [[ -z "$current_value" ]]; then
            log_warning "SSH setting not found: $key"
            validation_passed=false
        elif [[ "$current_value" != "$value" ]]; then
            log_warning "SSH setting mismatch: $key (current: $current_value, expected: $value)"
            validation_passed=false
        else
            log_info "SSH setting validated: $key = $value"
        fi
    done
    
    if [[ "$validation_passed" == "true" ]]; then
        log_success "SSH configuration security validation passed"
        return 0
    else
        log_warning "SSH configuration security validation failed"
        return 1
    fi
}

# COMMENT: Production Docker security validation with security
validate_docker_security() {
    # COMMENT: Check if Docker is available
    if ! command -v docker >/dev/null 2>&1; then
        log_warning "Docker command not available - Docker security validation skipped"
        return 0
    fi
    
    # COMMENT: Check Docker daemon status
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon is not running or not accessible"
        return 1
    fi
    
    log_info "Validating Docker security configuration"
    
    # COMMENT: Check Docker daemon configuration
    local daemon_config
    daemon_config=$(docker info 2>/dev/null | grep -E "(Security Options|Logging Driver|Cgroup Driver)")
    
    if [[ -n "$daemon_config" ]]; then
        log_info "Docker daemon configuration:"
        echo "$daemon_config" | while read -r line; do
            log_info "  $line"
        done
    fi
    
    # COMMENT: Check for running containers with privileged mode
    local privileged_containers
    privileged_containers=$(docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" 2>/dev/null | grep -E "privileged|true" || true)
    
    if [[ -n "$privileged_containers" ]]; then
        log_warning "Found containers running in privileged mode:"
        echo "$privileged_containers" | while read -r line; do
            log_warning "  $line"
        done
    else
        log_info "No privileged containers found"
    fi
    
    # COMMENT: Check for containers with sensitive capabilities
    local containers_with_caps
    containers_with_caps=$(docker ps --format "{{.Names}}" 2>/dev/null | xargs -I {} docker inspect {} --format "{{.Name}}: {{.HostConfig.CapAdd}}" 2>/dev/null | grep -v "null" || true)
    
    if [[ -n "$containers_with_caps" ]]; then
        log_warning "Found containers with added capabilities:"
        echo "$containers_with_caps" | while read -r line; do
            log_warning "  $line"
        done
    else
        log_info "No containers with added capabilities found"
    fi
    
    # COMMENT: Check Docker daemon security options
    local security_options
    security_options=$(docker info 2>/dev/null | grep -A 10 "Security Options" | grep -E "(seccomp|apparmor|selinux)" || true)
    
    if [[ -n "$security_options" ]]; then
        log_info "Docker security options:"
        echo "$security_options" | while read -r line; do
            log_info "  $line"
        done
    else
        log_warning "No security options found in Docker daemon"
    fi
    
    log_success "Docker security validation completed"
    return 0
}

# COMMENT: Production system user validation with security
validate_system_users() {
    local critical_users=("root" "{{ ansible_user | default('ansible') }}" "{{ backup_user | default('backup') }}")
    
    log_info "Validating system user security"
    
    local validation_passed=true
    
    for user in "${critical_users[@]}"; do
        if [[ -z "$user" ]]; then
            continue
        fi
        
        # COMMENT: Check if user exists
        if ! id "$user" >/dev/null 2>&1; then
            log_warning "User does not exist: $user"
            continue
        fi
        
        # COMMENT: Check user account status
        local account_status
        account_status=$(passwd -S "$user" 2>/dev/null | awk '{print $2}')
        
        if [[ "$account_status" == "L" ]]; then
            log_warning "User account is locked: $user"
        elif [[ "$account_status" == "P" ]]; then
            log_info "User account is active: $user"
        else
            log_warning "User account has unknown status: $user ($account_status)"
        fi
        
        # COMMENT: Check password expiration
        local password_expiry
        password_expiry=$(chage -l "$user" 2>/dev/null | grep "Password expires" | awk '{print $4}')
        
        if [[ "$password_expiry" == "never" ]]; then
            log_warning "User password never expires: $user"
        else
            log_info "User password expires: $user ($password_expiry)"
        fi
        
        # COMMENT: Check for users with UID 0 (other than root)
        if [[ "$user" != "root" ]]; then
            local user_uid
            user_uid=$(id -u "$user" 2>/dev/null)
            
            if [[ "$user_uid" -eq 0 ]]; then
                log_error "Non-root user has UID 0: $user"
                validation_passed=false
            fi
        fi
    done
    
    # COMMENT: Check for unauthorized users
    local unauthorized_users
    unauthorized_users=$(awk -F: '$3 >= 1000 && $3 != 65534 {print $1}' /etc/passwd 2>/dev/null | grep -v -E "({{ ansible_user | default('ansible') }}|{{ backup_user | default('backup') }})" || true)
    
    if [[ -n "$unauthorized_users" ]]; then
        log_warning "Found unauthorized users with UID >= 1000:"
        echo "$unauthorized_users" | while read -r user; do
            log_warning "  $user"
        done
    fi
    
    if [[ "$validation_passed" == "true" ]]; then
        log_success "System user security validation passed"
        return 0
    else
        log_warning "System user security validation failed"
        return 1
    fi
}

# COMMENT: Production network security validation with security
validate_network_security() {
    log_info "Validating network security configuration"
    
    # COMMENT: Check listening ports
    local listening_ports
    listening_ports=$(netstat -tlnp 2>/dev/null | grep LISTEN || ss -tlnp 2>/dev/null | grep LISTEN || true)
    
    if [[ -n "$listening_ports" ]]; then
        log_info "Listening network ports:"
        echo "$listening_ports" | while read -r line; do
            log_info "  $line"
        done
        
        # COMMENT: Check for potentially dangerous ports
        local dangerous_ports
        dangerous_ports=$(echo "$listening_ports" | grep -E ":(22|23|21|25|53|80|443|3306|5432|6379|27017)" || true)
        
        if [[ -n "$dangerous_ports" ]]; then
            log_info "Potentially sensitive services listening:"
            echo "$dangerous_ports" | while read -r line; do
                log_info "  $line"
            done
        fi
    else
        log_warning "Cannot determine listening ports"
    fi
    
    # COMMENT: Check for established connections
    local established_connections
    established_connections=$(netstat -tn 2>/dev/null | grep ESTABLISHED || ss -tn 2>/dev/null | grep ESTABLISHED || true)
    
    if [[ -n "$established_connections" ]]; then
        local connection_count
        connection_count=$(echo "$established_connections" | wc -l)
        log_info "Active network connections: $connection_count"
    fi
    
    # COMMENT: Check for suspicious network activity
    local suspicious_connections
    suspicious_connections=$(netstat -tn 2>/dev/null | grep -E "(ESTABLISHED|TIME_WAIT)" | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr | head -10 || true)
    
    if [[ -n "$suspicious_connections" ]]; then
        log_info "Top network connections by remote host:"
        echo "$suspicious_connections" | while read -r line; do
            log_info "  $line"
        done
    fi
    
    log_success "Network security validation completed"
    return 0
}

# COMMENT: Production comprehensive security scan with security
perform_security_scan() {
    local security_level="${1:-$DEFAULT_SECURITY_LEVEL}"
    local scan_output_file="${2:-}"
    
    # COMMENT: Input validation for security
    if ! validate_security_level "$security_level"; then
        log_error "Invalid security level for scan: $security_level"
        return 1
    fi
    
    # COMMENT: Set output file if not specified
    if [[ -z "$scan_output_file" ]]; then
        scan_output_file="$SCRIPT_DIR/../logs/security_scan_$(date +%Y%m%d_%H%M%S).log"
    fi
    
    # COMMENT: Create scan output directory
    local scan_output_dir
    scan_output_dir=$(dirname "$scan_output_file")
    
    if [[ ! -d "$scan_output_dir" ]]; then
        if ! mkdir -p "$scan_output_dir" 2>/dev/null; then
            log_error "Failed to create scan output directory: $scan_output_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on output directory
    if ! chmod 750 "$scan_output_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on scan output directory"
    fi
    
    log_info "Starting comprehensive security scan (level: $security_level)"
    log_info "Scan output: $scan_output_file"
    
    # COMMENT: Initialize scan results
    local scan_results=()
    local scan_start_time
    scan_start_time=$(date +%s)
    
    # COMMENT: Perform security validations based on level
    case "$security_level" in
        low)
            scan_results+=("Basic security validation")
            validate_firewall_rules
            validate_ssh_config
            ;;
        medium)
            scan_results+=("Medium security validation")
            validate_firewall_rules
            validate_ssh_config
            validate_docker_security
            validate_system_users
            ;;
        high|critical)
            scan_results+=("Comprehensive security validation")
            validate_firewall_rules
            validate_ssh_config
            validate_docker_security
            validate_system_users
            validate_network_security
            
            # COMMENT: Additional critical validations
            if [[ "$security_level" == "critical" ]]; then
                scan_results+=("Critical security validation")
                # COMMENT: Add critical security checks here
            fi
            ;;
    esac
    
    # COMMENT: Calculate scan duration
    local scan_end_time scan_duration
    scan_end_time=$(date +%s)
    scan_duration=$((scan_end_time - scan_start_time))
    
    # COMMENT: Generate scan summary
    local scan_summary="
=== SECURITY SCAN SUMMARY ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $SECURITY_UTILS_ENVIRONMENT
Security Level: $security_level
Duration: ${scan_duration}s
Output File: $scan_output_file

Validations Performed:
$(printf "  - %s\n" "${scan_results[@]}")

Scan completed successfully.
"
    
    # COMMENT: Write scan results to output file
    if echo "$scan_summary" > "$scan_output_file" 2>/dev/null; then
        log_success "Security scan completed successfully in ${scan_duration}s"
        log_info "Scan results written to: $scan_output_file"
        
        # COMMENT: Set secure permissions on output file
        if ! chmod 640 "$scan_output_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on scan output file"
        fi
        
        return 0
    else
        log_error "Failed to write scan results to output file"
        return 1
    fi
}

# COMMENT: Production security hardening with validation
harden_system_security() {
    local security_level="${1:-$DEFAULT_SECURITY_LEVEL}"
    local dry_run="${2:-false}"
    
    # COMMENT: Input validation for security
    if ! validate_security_level "$security_level"; then
        log_error "Invalid security level for hardening: $security_level"
        return 1
    fi
    
    log_info "Starting system security hardening (level: $security_level, dry_run: $dry_run)"
    
    # COMMENT: Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "Security hardening requires root privileges"
        return 1
    fi
    
    # COMMENT: Create backup before hardening
    local backup_dir backup_timestamp
    backup_dir="$SCRIPT_DIR/../backups/security"
    backup_timestamp=$(date +%Y%m%d_%H%M%S)
    
    if [[ ! -d "$backup_dir" ]]; then
        if ! mkdir -p "$backup_dir" 2>/dev/null; then
            log_error "Failed to create backup directory: $backup_dir"
            return 1
        fi
    fi
    
    # COMMENT: Backup critical configuration files
    local config_files=("/etc/ssh/sshd_config" "/etc/ufw/ufw.conf" "/etc/docker/daemon.json")
    
    for config_file in "${config_files[@]}"; do
        if [[ -f "$config_file" ]]; then
            local backup_file
            backup_file="$backup_dir/$(basename "$config_file").$backup_timestamp"
            
            if ! cp "$config_file" "$backup_file" 2>/dev/null; then
                log_warning "Failed to backup configuration file: $config_file"
            else
                log_info "Backed up configuration file: $config_file -> $backup_file"
                
                # COMMENT: Set secure permissions on backup
                if ! chmod 600 "$backup_file" 2>/dev/null; then
                    log_warning "Failed to set secure permissions on backup file"
                fi
            fi
        fi
    done
    
    # COMMENT: Perform security hardening based on level
    case "$security_level" in
        low)
            log_info "Performing basic security hardening"
            # COMMENT: Basic hardening tasks
            ;;
        medium)
            log_info "Performing medium security hardening"
            # COMMENT: Medium hardening tasks
            ;;
        high|critical)
            log_info "Performing comprehensive security hardening"
            # COMMENT: Comprehensive hardening tasks
            ;;
    esac
    
    log_success "System security hardening completed"
    return 0
}

# COMMENT: Production security monitoring setup with validation
setup_security_monitoring() {
    local monitoring_config="${1:-}"
    
    log_info "Setting up security monitoring"
    
    # COMMENT: Check if monitoring tools are available
    local monitoring_tools=("auditd" "fail2ban" "logwatch" "rkhunter")
    local available_tools=()
    
    for tool in "${monitoring_tools[@]}"; do
        if command -v "$tool" >/dev/null 2>&1; then
            available_tools+=("$tool")
        else
            log_warning "Security monitoring tool not available: $tool"
        fi
    done
    
    if [[ ${#available_tools[@]} -eq 0 ]]; then
        log_error "No security monitoring tools available"
        return 1
    fi
    
    log_info "Available security monitoring tools: ${available_tools[*]}"
    
    # COMMENT: Setup auditd if available
    if [[ " ${available_tools[*]} " =~ " auditd " ]]; then
        log_info "Setting up auditd security monitoring"
        
        # COMMENT: Check auditd status
        if systemctl is-active --quiet auditd; then
            log_info "auditd service is running"
        else
            log_warning "auditd service is not running"
        fi
    fi
    
    # COMMENT: Setup fail2ban if available
    if [[ " ${available_tools[*]} " =~ " fail2ban " ]]; then
        log_info "Setting up fail2ban security monitoring"
        
        # COMMENT: Check fail2ban status
        if systemctl is-active --quiet fail2ban; then
            log_info "fail2ban service is running"
        else
            log_warning "fail2ban service is not running"
        fi
    fi
    
    log_success "Security monitoring setup completed"
    return 0
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Security Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive security functions for production use.
    It includes validation, hardening, monitoring, and security scanning.

FUNCTIONS:
    validate_security_level <level> - Validate security level
    validate_file_permissions <file> [expected] - Validate file permissions
    validate_file_ownership <file> [owner] [group] - Validate file ownership
    validate_ssl_certificate <hostname> [port] [timeout] - Validate SSL certificate
    validate_firewall_rules [expected] - Validate firewall configuration
    validate_ssh_config [config_file] - Validate SSH security configuration
    validate_docker_security - Validate Docker security configuration
    validate_system_users - Validate system user security
    validate_network_security - Validate network security configuration
    perform_security_scan [level] [output_file] - Perform comprehensive security scan
    harden_system_security [level] [dry_run] - Harden system security
    setup_security_monitoring [config] - Setup security monitoring

SECURITY LEVELS:
    low, medium, high, critical

SECURITY FEATURES:
    - Input validation and sanitization
    - File permission and ownership validation
    - SSL certificate validation
    - Firewall and SSH configuration validation
    - Docker security validation
    - System user security validation
    - Network security validation
    - Comprehensive security scanning
    - System security hardening
    - Security monitoring setup

EXAMPLES:
    source $SCRIPT_NAME
    validate_ssl_certificate "example.com" 443
    perform_security_scan "high" "/var/log/security_scan.log"
    harden_system_security "medium" "false"
    setup_security_monitoring

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize security utilities if not already done
    if [[ -z "${SECURITY_UTILS_INITIALIZED:-}" ]]; then
        export SECURITY_UTILS_INITIALIZED="true"
        log_info "Security utilities initialized successfully"
    fi
    
    # COMMENT: Log successful loading
    log_info "Security utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
