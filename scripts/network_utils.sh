#!/bin/bash
# COMMENT: Production-ready Network Utilities for Ansible Homelab
# COMMENT: Comprehensive network management, connectivity testing, and configuration
# COMMENT: Generated by: {{ ansible_managed }}
# COMMENT: Timestamp: {{ ansible_date_time.iso8601 }}
# COMMENT: Environment: {{ deployment_environment | default('production') }}

# COMMENT: Production security settings for network utility reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="network_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production network configuration with validation
NETWORK_OPERATIONS=("test" "scan" "configure" "monitor" "diagnose" "backup" "restore")
DEFAULT_NETWORK_OPERATION="test"
NETWORK_TIMEOUT=30
NETWORK_RETRIES=3
NETWORK_RETRY_DELAY=5
NETWORK_SCAN_TIMEOUT=300
NETWORK_MONITOR_INTERVAL=60

# COMMENT: Production environment variables with validation
export NETWORK_UTILS_ENVIRONMENT="{{ deployment_environment | default('production') }}"
export NETWORK_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Source logging utilities if available
if [[ -f "$SCRIPT_DIR/logging_utils.sh" ]]; then
    source "$SCRIPT_DIR/logging_utils.sh"
else
    # COMMENT: Fallback logging if utilities not available
    log_info() { echo "[INFO] $1"; }
    log_warning() { echo "[WARNING] $1" >&2; }
    log_error() { echo "[ERROR] $1" >&2; }
    log_success() { echo "[SUCCESS] $1"; }
fi

# COMMENT: Source security utilities if available
if [[ -f "$SCRIPT_DIR/security_utils.sh" ]]; then
    source "$SCRIPT_DIR/security_utils.sh"
else
    # COMMENT: Fallback security if utilities not available
    validate_network_security() { log_warning "Security utilities not available"; return 0; }
fi

# COMMENT: Production network operation validation with security
validate_network_operation() {
    local operation="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$operation" ]]; then
        log_error "Network operation not specified"
        return 1
    fi
    
    # COMMENT: Validate network operation
    case "$operation" in
        test|scan|configure|monitor|diagnose|backup|restore)
            return 0
            ;;
        *)
            log_error "Invalid network operation: $operation"
            return 1
            ;;
    esac
}

# COMMENT: Production IP address validation with security
validate_ip_address() {
    local ip_address="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$ip_address" ]]; then
        log_error "IP address not specified"
        return 1
    fi
    
    # COMMENT: Validate IPv4 format
    if echo "$ip_address" | grep -E '^([0-9]{1,3}\.){3}[0-9]{1,3}$' >/dev/null; then
        # COMMENT: Check each octet range
        local IFS='.'
        read -ra octets <<< "$ip_address"
        for octet in "${octets[@]}"; do
            if [[ "$octet" -lt 0 || "$octet" -gt 255 ]]; then
                log_error "Invalid IP address octet: $octet"
                return 1
            fi
        done
        return 0
    fi
    
    # COMMENT: Validate IPv6 format (basic)
    if echo "$ip_address" | grep -E '^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$' >/dev/null; then
        return 0
    fi
    
    log_error "Invalid IP address format: $ip_address"
    return 1
}

# COMMENT: Production hostname validation with security
validate_hostname() {
    local hostname="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$hostname" ]]; then
        log_error "Hostname not specified"
        return 1
    fi
    
    # COMMENT: Validate hostname format
    if echo "$hostname" | grep -E '^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' >/dev/null; then
        return 0
    fi
    
    log_error "Invalid hostname format: $hostname"
    return 1
}

# COMMENT: Production port validation with security
validate_port() {
    local port="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$port" ]]; then
        log_error "Port not specified"
        return 1
    fi
    
    # COMMENT: Validate port number range
    if echo "$port" | grep -E '^[0-9]+$' >/dev/null && [[ "$port" -ge 1 && "$port" -le 65535 ]]; then
        return 0
    fi
    
    log_error "Invalid port number: $port (must be 1-65535)"
    return 1
}

# COMMENT: Production network connectivity test with validation
test_network_connectivity() {
    local target="$1"
    local port="${2:-}"
    local timeout="${3:-$NETWORK_TIMEOUT}"
    local retries="${4:-$NETWORK_RETRIES}"
    
    # COMMENT: Input validation for security
    if [[ -z "$target" ]]; then
        log_error "Target not specified for connectivity test"
        return 1
    fi
    
    # COMMENT: Validate timeout
    if ! echo "$timeout" | grep -E '^[0-9]+$' >/dev/null || [[ "$timeout" -lt 1 ]]; then
        log_warning "Invalid timeout: $timeout, using default: $NETWORK_TIMEOUT"
        timeout="$NETWORK_TIMEOUT"
    fi
    
    # COMMENT: Validate retries
    if ! echo "$retries" | grep -E '^[0-9]+$' >/dev/null || [[ "$retries" -lt 1 ]]; then
        log_warning "Invalid retries: $retries, using default: $NETWORK_RETRIES"
        retries="$NETWORK_RETRIES"
    fi
    
    log_info "Testing network connectivity to: $target (timeout: ${timeout}s, retries: $retries)"
    
    # COMMENT: Determine target type and test accordingly
    if validate_ip_address "$target"; then
        # COMMENT: IP address connectivity test
        if [[ -n "$port" ]]; then
            if ! validate_port "$port"; then
                return 1
            fi
            
            log_info "Testing TCP connectivity to $target:$port"
            
            # COMMENT: Test TCP connectivity
            local retry_count=0
            while [[ $retry_count -lt $retries ]]; do
                if timeout "$timeout" bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
                    log_success "TCP connectivity to $target:$port successful"
                    return 0
                else
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -lt $retries ]]; then
                        log_warning "TCP connectivity to $target:$port failed (attempt $retry_count/$retries)"
                        sleep "$NETWORK_RETRY_DELAY"
                    fi
                fi
            done
            
            log_error "TCP connectivity to $target:$port failed after $retries attempts"
            return 1
        else
            # COMMENT: Test basic IP connectivity with ping
            log_info "Testing IP connectivity to $target"
            
            local retry_count=0
            while [[ $retry_count -lt $retries ]]; do
                if timeout "$timeout" ping -c 1 -W 5 "$target" >/dev/null 2>&1; then
                    log_success "IP connectivity to $target successful"
                    return 0
                else
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -lt $retries ]]; then
                        log_warning "IP connectivity to $target failed (attempt $retry_count/$retries)"
                        sleep "$NETWORK_RETRY_DELAY"
                    fi
                fi
            done
            
            log_error "IP connectivity to $target failed after $retries attempts"
            return 1
        fi
    elif validate_hostname "$target"; then
        # COMMENT: Hostname connectivity test
        if [[ -n "$port" ]]; then
            if ! validate_port "$port"; then
                return 1
            fi
            
            log_info "Testing hostname connectivity to $target:$port"
            
            # COMMENT: Test hostname resolution and connectivity
            local retry_count=0
            while [[ $retry_count -lt $retries ]]; do
                if timeout "$timeout" bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
                    log_success "Hostname connectivity to $target:$port successful"
                    return 0
                else
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -lt $retries ]]; then
                        log_warning "Hostname connectivity to $target:$port failed (attempt $retry_count/$retries)"
                        sleep "$NETWORK_RETRY_DELAY"
                    fi
                fi
            done
            
            log_error "Hostname connectivity to $target:$port failed after $retries attempts"
            return 1
        else
            # COMMENT: Test hostname resolution
            log_info "Testing hostname resolution for $target"
            
            local retry_count=0
            while [[ $retry_count -lt $retries ]]; do
                if timeout "$timeout" nslookup "$target" >/dev/null 2>&1 || timeout "$timeout" dig "$target" +short >/dev/null 2>&1; then
                    log_success "Hostname resolution for $target successful"
                    return 0
                else
                    retry_count=$((retry_count + 1))
                    if [[ $retry_count -lt $retries ]]; then
                        log_warning "Hostname resolution for $target failed (attempt $retry_count/$retries)"
                        sleep "$NETWORK_RETRY_DELAY"
                    fi
                fi
            done
            
            log_error "Hostname resolution for $target failed after $retries attempts"
            return 1
        fi
    else
        log_error "Invalid target format: $target"
        return 1
    fi
}

# COMMENT: Production network port scan with validation
scan_network_ports() {
    local target="$1"
    local port_range="${2:-1-1024}"
    local scan_type="${3:-tcp}"
    local output_file="${4:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$target" ]]; then
        log_error "Target not specified for port scan"
        return 1
    fi
    
    if ! validate_ip_address "$target" && ! validate_hostname "$target"; then
        log_error "Invalid target format: $target"
        return 1
    fi
    
    # COMMENT: Validate scan type
    case "$scan_type" in
        tcp|udp|both)
            ;;
        *)
            log_error "Invalid scan type: $scan_type"
            return 1
            ;;
    esac
    
    log_info "Starting network port scan: $target (range: $port_range, type: $scan_type)"
    
    # COMMENT: Check if nmap is available
    if ! command -v nmap >/dev/null 2>&1; then
        log_error "nmap command not available for port scanning"
        return 1
    fi
    
    # COMMENT: Prepare nmap command as bash array to avoid IFS issues
    local nmap_cmd=()
    
    case "$scan_type" in
        tcp)
            nmap_cmd=(nmap -sS -p "$port_range" "$target")
            ;;
        udp)
            nmap_cmd=(nmap -sU -p "$port_range" "$target")
            ;;
        both)
            nmap_cmd=(nmap -sS -sU -p "$port_range" "$target")
            ;;
    esac
    
    # COMMENT: Execute port scan
    log_info "Executing port scan: ${nmap_cmd[*]}"
    
    local scan_output
    if scan_output=$(timeout "$NETWORK_SCAN_TIMEOUT" "${nmap_cmd[@]}" 2>/dev/null); then
        if [[ -n "$output_file" ]]; then
            # COMMENT: Write scan results to output file
            local output_dir
            output_dir=$(dirname "$output_file")
            
            if [[ ! -d "$output_dir" ]]; then
                if ! mkdir -p "$output_dir" 2>/dev/null; then
                    log_error "Failed to create output directory: $output_dir"
                    return 1
                fi
            fi
            
            if echo "$scan_output" > "$output_file" 2>/dev/null; then
                # COMMENT: Set secure permissions on output file
                if ! chmod 640 "$output_file" 2>/dev/null; then
                    log_warning "Failed to set secure permissions on output file"
                fi
                
                log_success "Port scan results written to: $output_file"
            else
                log_error "Failed to write port scan results to output file"
                return 1
            fi
        fi
        
        # COMMENT: Display scan results
        log_info "Port scan results for $target:"
        echo "$scan_output"
        
        log_success "Network port scan completed successfully"
        return 0
    else
        log_error "Network port scan failed for $target"
        return 1
    fi
}

# COMMENT: Production network interface configuration with validation
configure_network_interface() {
    local interface_name="$1"
    local config_type="$2"
    local config_value="$3"
    
    # COMMENT: Input validation for security
    if [[ -z "$interface_name" ]]; then
        log_error "Interface name not specified"
        return 1
    fi
    
    if [[ -z "$config_type" ]]; then
        log_error "Configuration type not specified"
        return 1
    fi
    
    if [[ -z "$config_value" ]]; then
        log_error "Configuration value not specified"
        return 1
    fi
    
    # COMMENT: Sanitize interface name for security
    interface_name=$(echo "$interface_name" | sed 's/[^a-zA-Z0-9._-]/_/g')
    
    if [[ -z "$interface_name" ]]; then
        log_error "Invalid interface name after sanitization"
        return 1
    fi
    
    # COMMENT: Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "Network interface configuration requires root privileges"
        return 1
    fi
    
    log_info "Configuring network interface: $interface_name ($config_type: $config_value)"
    
    # COMMENT: Check if interface exists
    if ! ip link show "$interface_name" >/dev/null 2>&1; then
        log_error "Network interface does not exist: $interface_name"
        return 1
    fi
    
    # COMMENT: Configure interface based on type
    case "$config_type" in
        up|down)
            if ip link set "$interface_name" "$config_type" 2>/dev/null; then
                log_success "Interface $interface_name set to $config_type"
                return 0
            else
                log_error "Failed to set interface $interface_name to $config_type"
                return 1
            fi
            ;;
        ip)
            if ! validate_ip_address "$config_value"; then
        ip)
            # Accept CIDR (e.g., 192.168.1.10/24) or plain IP
            if ! echo "$config_value" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}(/[0-9]{1,2})?
        mtu)
            if ! echo "$config_value" | grep -E '^[0-9]+$' >/dev/null || [[ "$config_value" -lt 68 || "$config_value" -gt 9000 ]]; then
                log_error "Invalid MTU value: $config_value (must be 68-9000)"
                return 1
            fi
            
            if ip link set "$interface_name" mtu "$config_value" 2>/dev/null; then
                log_success "MTU set to $config_value for interface $interface_name"
                return 0
            else
                log_error "Failed to set MTU to $config_value for interface $interface_name"
                return 1
            fi
            ;;
        *)
            log_error "Unsupported configuration type: $config_type"
            return 1
            ;;
    esac
}

# COMMENT: Production network monitoring with validation
monitor_network() {
    local monitoring_level="${1:-basic}"
    local monitoring_duration="${2:-300}"
    local output_file="${3:-}"
    
    # COMMENT: Input validation for security
    case "$monitoring_level" in
        basic|detailed|comprehensive)
            ;;
        *)
            log_error "Invalid monitoring level: $monitoring_level"
            return 1
            ;;
    esac
    
    # COMMENT: Validate monitoring duration
    if ! echo "$monitoring_duration" | grep -E '^[0-9]+$' >/dev/null || [[ "$monitoring_duration" -lt 60 ]]; then
        log_warning "Invalid monitoring duration: $monitoring_duration, using default: 300"
        monitoring_duration=300
    fi
    
    log_info "Starting network monitoring (level: $monitoring_level, duration: ${monitoring_duration}s)"
    
    # COMMENT: Set output file if not specified
    if [[ -z "$output_file" ]]; then
        output_file="$SCRIPT_DIR/../logs/network_monitoring_$(date +%Y%m%d_%H%M%S).log"
    fi
    
    # COMMENT: Create monitoring output directory
    local output_dir
    output_dir=$(dirname "$output_file")
    
    if [[ ! -d "$output_dir" ]]; then
        if ! mkdir -p "$output_dir" 2>/dev/null; then
            log_error "Failed to create monitoring output directory: $output_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on output directory
    if ! chmod 750 "$output_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on monitoring output directory"
    fi
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local monitoring_start_time
    monitoring_start_time=$(date +%s)
    
    # COMMENT: Monitor network interfaces
    log_info "Monitoring network interfaces"
    
    local network_interfaces
    network_interfaces=$(ip -o link show 2>/dev/null | awk '{print $2}' | cut -d: -f1 | grep -v lo || true)
    
    if [[ -n "$network_interfaces" ]]; then
        monitoring_results+=("Network interfaces: $(echo "$network_interfaces" | wc -l)")
        
        echo "$network_interfaces" | while read -r interface; do
            local interface_status
            interface_status=$(ip link show "$interface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2 || echo "UNKNOWN")
            monitoring_results+=("  $interface: $interface_status")
        done
    fi
    
    # COMMENT: Monitor network connections
    log_info "Monitoring network connections"
    
    local listening_ports
    listening_ports=$(netstat -tlnp 2>/dev/null | grep LISTEN || ss -tlnp 2>/dev/null | grep LISTEN || true)
    
    if [[ -n "$listening_ports" ]]; then
        local port_count
        port_count=$(echo "$listening_ports" | wc -l)
        monitoring_results+=("Listening ports: $port_count")
        
        if [[ "$monitoring_level" == "detailed" || "$monitoring_level" == "comprehensive" ]]; then
            monitoring_results+=("Port details:")
            echo "$listening_ports" | head -10 | while read -r line; do
                monitoring_results+=("  $line")
            done
        fi
    fi
    
    # COMMENT: Monitor network traffic
    if [[ "$monitoring_level" == "comprehensive" ]]; then
        log_info "Monitoring network traffic"
        
        # COMMENT: Get network statistics
        local network_stats
        network_stats=$(netstat -i 2>/dev/null | tail -n +3 || true)
        
        if [[ -n "$network_stats" ]]; then
            monitoring_results+=("Network statistics:")
            echo "$network_stats" | while read -r line; do
                monitoring_results+=("  $line")
            done
        fi
    fi
    
    # COMMENT: Monitor for specified duration
    local monitoring_end_time
    monitoring_end_time=$((monitoring_start_time + monitoring_duration))
    
    log_info "Monitoring network for ${monitoring_duration}s"
    
    while [[ $(date +%s) -lt $monitoring_end_time ]]; do
        # COMMENT: Basic network health check
        local connectivity_targets=("8.8.8.8" "1.1.1.1")
        
        for target in "${connectivity_targets[@]}"; do
            if test_network_connectivity "$target" >/dev/null 2>&1; then
                monitoring_results+=("Connectivity to $target: OK")
            else
                monitoring_results+=("Connectivity to $target: FAILED")
            fi
        done
        
        sleep "$NETWORK_MONITOR_INTERVAL"
    done
    
    # COMMENT: Calculate monitoring duration
    local actual_duration
    actual_duration=$(($(date +%s) - monitoring_start_time))
    
    # COMMENT: Generate monitoring summary
    local monitoring_summary="
=== NETWORK MONITORING SUMMARY ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $NETWORK_UTILS_ENVIRONMENT
Monitoring Level: $monitoring_level
Duration: ${actual_duration}s
Output File: $output_file

Monitoring Results:
$(printf "  - %s\n" "${monitoring_results[@]}")

Network monitoring completed successfully.
"
    
    # COMMENT: Write monitoring results to output file
    if echo "$monitoring_summary" > "$output_file" 2>/dev/null; then
        log_success "Network monitoring completed successfully in ${actual_duration}s"
        log_info "Monitoring results written to: $output_file"
        
        # COMMENT: Set secure permissions on output file
        if ! chmod 640 "$output_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on monitoring output file"
        fi
        
        return 0
    else
        log_error "Failed to write monitoring results to output file"
        return 1
    fi
}

# COMMENT: Production network diagnosis with validation
diagnose_network() {
    local target="$1"
    local diagnosis_type="${2:-comprehensive}"
    local output_file="${3:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$target" ]]; then
        log_error "Target not specified for network diagnosis"
        return 1
    fi
    
    if ! validate_ip_address "$target" && ! validate_hostname "$target"; then
        log_error "Invalid target format: $target"
        return 1
    fi
    
    case "$diagnosis_type" in
        basic|detailed|comprehensive)
            ;;
        *)
            log_error "Invalid diagnosis type: $diagnosis_type"
            return 1
            ;;
    esac
    
    log_info "Starting network diagnosis: $target (type: $diagnosis_type)"
    
    # COMMENT: Set output file if not specified
    if [[ -z "$output_file" ]]; then
        output_file="$SCRIPT_DIR/../logs/network_diagnosis_$(date +%Y%m%d_%H%M%S).log"
    fi
    
    # COMMENT: Create diagnosis output directory
    local output_dir
    output_dir=$(dirname "$output_file")
    
    if [[ ! -d "$output_dir" ]]; then
        if ! mkdir -p "$output_dir" 2>/dev/null; then
            log_error "Failed to create diagnosis output directory: $output_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on output directory
    if ! chmod 750 "$output_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on diagnosis output directory"
    fi
    
    # COMMENT: Initialize diagnosis results
    local diagnosis_results=()
    local diagnosis_start_time
    diagnosis_start_time=$(date +%s)
    
    # COMMENT: Basic connectivity test
    diagnosis_results+=("Basic connectivity test")
    if test_network_connectivity "$target" >/dev/null 2>&1; then
        diagnosis_results+=("  Basic connectivity: OK")
    else
        diagnosis_results+=("  Basic connectivity: FAILED")
    fi
    
    # COMMENT: DNS resolution test (for hostnames)
    if validate_hostname "$target"; then
        diagnosis_results+=("DNS resolution test")
        if nslookup "$target" >/dev/null 2>&1 || dig "$target" +short >/dev/null 2>&1; then
            diagnosis_results+=("  DNS resolution: OK")
        else
            diagnosis_results+=("  DNS resolution: FAILED")
        fi
    fi
    
    # COMMENT: Traceroute test
    if command -v traceroute >/dev/null 2>&1; then
        diagnosis_results+=("Traceroute test")
        local traceroute_output
        if traceroute_output=$(timeout 60 traceroute "$target" 2>/dev/null); then
            diagnosis_results+=("  Traceroute: OK")
            if [[ "$diagnosis_type" == "detailed" || "$diagnosis_type" == "comprehensive" ]]; then
                diagnosis_results+=("  Traceroute details:")
                echo "$traceroute_output" | while read -r line; do
                    diagnosis_results+=("    $line")
                done
            fi
        else
            diagnosis_results+=("  Traceroute: FAILED")
        fi
    fi
    
    # COMMENT: Port scan test
    if [[ "$diagnosis_type" == "comprehensive" ]]; then
        diagnosis_results+=("Port scan test")
        if scan_network_ports "$target" "80,443,22,53" "tcp" >/dev/null 2>&1; then
            diagnosis_results+=("  Port scan: OK")
        else
            diagnosis_results+=("  Port scan: FAILED")
        fi
    fi
    
    # COMMENT: Calculate diagnosis duration
    local diagnosis_end_time diagnosis_duration
    diagnosis_end_time=$(date +%s)
    diagnosis_duration=$((diagnosis_end_time - diagnosis_start_time))
    
    # COMMENT: Generate diagnosis summary
    local diagnosis_summary="
=== NETWORK DIAGNOSIS SUMMARY ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $NETWORK_UTILS_ENVIRONMENT
Target: $target
Diagnosis Type: $diagnosis_type
Duration: ${diagnosis_duration}s
Output File: $output_file

Diagnosis Results:
$(printf "  - %s\n" "${diagnosis_results[@]}")

Network diagnosis completed successfully.
"
    
    # COMMENT: Write diagnosis results to output file
    if echo "$diagnosis_summary" > "$output_file" 2>/dev/null; then
        log_success "Network diagnosis completed successfully in ${diagnosis_duration}s"
        log_info "Diagnosis results written to: $output_file"
        
        # COMMENT: Set secure permissions on output file
        if ! chmod 640 "$output_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on diagnosis output file"
        fi
        
        return 0
    else
        log_error "Failed to write diagnosis results to output file"
        return 1
    fi
}

# COMMENT: Production network configuration backup with validation
backup_network_config() {
    local backup_dir="$1"
    local backup_name="${2:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_dir" ]]; then
        backup_dir="$SCRIPT_DIR/../backups/network"
    fi
    
    # COMMENT: Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "Network configuration backup requires root privileges"
        return 1
    fi
    
    log_info "Starting network configuration backup: $backup_dir"
    
    # COMMENT: Validate backup directory
    if [[ ! -d "$backup_dir" ]]; then
        if ! mkdir -p "$backup_dir" 2>/dev/null; then
            log_error "Failed to create backup directory: $backup_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on backup directory
    if ! chmod 750 "$backup_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on backup directory"
    fi
    
    # COMMENT: Generate backup name if not provided
    if [[ -z "$backup_name" ]]; then
        local timestamp
        timestamp=$(date +%Y%m%d_%H%M%S)
        backup_name="network_config_backup_${timestamp}"
    fi
    
    # COMMENT: Create backup directory for this backup
    local config_backup_dir
    config_backup_dir="$backup_dir/$backup_name"
    
    if ! mkdir -p "$config_backup_dir" 2>/dev/null; then
        log_error "Failed to create config backup directory: $config_backup_dir"
        return 1
    fi
    
    # COMMENT: Set secure permissions on config backup directory
    if ! chmod 750 "$config_backup_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on config backup directory"
    fi
    
    # COMMENT: Backup network configuration files
    local config_files=(
        "/etc/network/interfaces"
        "/etc/netplan"
        "/etc/systemd/network"
        "/etc/resolv.conf"
        "/etc/hosts"
        "/etc/hostname"
    )
    
    for config_file in "${config_files[@]}"; do
        if [[ -e "$config_file" ]]; then
            local backup_file
            backup_file="$config_backup_dir/$(basename "$config_file")"
            
            if cp -r "$config_file" "$backup_file" 2>/dev/null; then
                # COMMENT: Set secure permissions on backup file
                if ! chmod 640 "$backup_file" 2>/dev/null; then
                    log_warning "Failed to set secure permissions on backup file: $backup_file"
                fi
                
                log_info "Backed up configuration: $config_file -> $backup_file"
            else
                log_warning "Failed to backup configuration: $config_file"
            fi
        fi
    done
    
    # COMMENT: Backup current network state
    local network_state_file
    network_state_file="$config_backup_dir/network_state.txt"
    
    local network_state="
=== NETWORK STATE BACKUP ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $NETWORK_UTILS_ENVIRONMENT

Network Interfaces:
$(ip -o link show 2>/dev/null || echo "Failed to get network interfaces")

IP Addresses:
$(ip -o addr show 2>/dev/null || echo "Failed to get IP addresses")

Routing Table:
$(ip route show 2>/dev/null || echo "Failed to get routing table")

Network Connections:
$(netstat -tlnp 2>/dev/null | head -20 || ss -tlnp 2>/dev/null | head -20 || echo "Failed to get network connections")
"
    
    if echo "$network_state" > "$network_state_file" 2>/dev/null; then
        # COMMENT: Set secure permissions on state file
        if ! chmod 640 "$network_state_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on network state file"
        fi
        
        log_info "Network state backed up: $network_state_file"
    else
        log_warning "Failed to backup network state"
    fi
    
    # COMMENT: Compress backup directory
    local compressed_backup
    compressed_backup="$backup_dir/${backup_name}.tar.gz"
    
    log_info "Compressing backup: $config_backup_dir -> $compressed_backup"
    
    if tar -czf "$compressed_backup" -C "$backup_dir" "$backup_name" 2>/dev/null; then
        # COMMENT: Set secure permissions on compressed backup
        if ! chmod 640 "$compressed_backup" 2>/dev/null; then
            log_warning "Failed to set secure permissions on compressed backup"
        fi
        
        log_success "Backup compressed: $compressed_backup"
        
        # COMMENT: Remove uncompressed backup directory
        if ! rm -rf "$config_backup_dir" 2>/dev/null; then
            log_warning "Failed to remove uncompressed backup directory"
        fi
        
        log_success "Network configuration backup completed successfully: $compressed_backup"
        return 0
    else
        log_error "Failed to compress backup: $config_backup_dir"
        return 1
    fi
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Network Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive network functions for production use.
    It includes connectivity testing, port scanning, configuration, and monitoring.

FUNCTIONS:
    validate_network_operation <operation> - Validate network operation
    validate_ip_address <ip> - Validate IP address format
    validate_hostname <hostname> - Validate hostname format
    validate_port <port> - Validate port number
    test_network_connectivity <target> [port] [timeout] [retries] - Test connectivity
    scan_network_ports <target> [range] [type] [output] - Scan network ports
    configure_network_interface <interface> <type> <value> - Configure interface
    monitor_network [level] [duration] [output] - Monitor network
    diagnose_network <target> [type] [output] - Diagnose network issues
    backup_network_config [dir] [name] - Backup network configuration

NETWORK OPERATIONS:
    test, scan, configure, monitor, diagnose, backup, restore

MONITORING LEVELS:
    basic, detailed, comprehensive

DIAGNOSIS TYPES:
    basic, detailed, comprehensive

SECURITY FEATURES:
    - Input validation and sanitization
    - IP address and hostname validation
    - Port number validation
    - Secure file permissions
    - Comprehensive error handling

EXAMPLES:
    source $SCRIPT_NAME
    test_network_connectivity "example.com" 80
    scan_network_ports "192.168.1.1" "1-1000" "tcp"
    monitor_network "detailed" 600
    diagnose_network "example.com" "comprehensive"
    backup_network_config "/backups" "network_backup"

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize network utilities if not already done
    if [[ -z "${NETWORK_UTILS_INITIALIZED:-}" ]]; then
        export NETWORK_UTILS_INITIALIZED="true"
        log_info "Network utilities initialized successfully"
    fi
    
    # COMMENT: Log successful loading
    log_info "Network utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
; then
                return 1
            fi
            
            if ip addr add "$config_value" dev "$interface_name" 2>/dev/null; then
                log_success "IP address $config_value added to interface $interface_name"
                return 0
            else
                log_error "Failed to add IP address $config_value to interface $interface_name"
                return 1
        mtu)
            if ! echo "$config_value" | grep -E '^[0-9]+$' >/dev/null || [[ "$config_value" -lt 68 || "$config_value" -gt 9000 ]]; then
                log_error "Invalid MTU value: $config_value (must be 68-9000)"
                return 1
            fi
            
            if ip link set "$interface_name" mtu "$config_value" 2>/dev/null; then
                log_success "MTU set to $config_value for interface $interface_name"
                return 0
            else
                log_error "Failed to set MTU to $config_value for interface $interface_name"
                return 1
            fi
            ;;
        *)
            log_error "Unsupported configuration type: $config_type"
            return 1
            ;;
    esac
}

# COMMENT: Production network monitoring with validation
monitor_network() {
    local monitoring_level="${1:-basic}"
    local monitoring_duration="${2:-300}"
    local output_file="${3:-}"
    
    # COMMENT: Input validation for security
    case "$monitoring_level" in
        basic|detailed|comprehensive)
            ;;
        *)
            log_error "Invalid monitoring level: $monitoring_level"
            return 1
            ;;
    esac
    
    # COMMENT: Validate monitoring duration
    if ! echo "$monitoring_duration" | grep -E '^[0-9]+$' >/dev/null || [[ "$monitoring_duration" -lt 60 ]]; then
        log_warning "Invalid monitoring duration: $monitoring_duration, using default: 300"
        monitoring_duration=300
    fi
    
    log_info "Starting network monitoring (level: $monitoring_level, duration: ${monitoring_duration}s)"
    
    # COMMENT: Set output file if not specified
    if [[ -z "$output_file" ]]; then
        output_file="$SCRIPT_DIR/../logs/network_monitoring_$(date +%Y%m%d_%H%M%S).log"
    fi
    
    # COMMENT: Create monitoring output directory
    local output_dir
    output_dir=$(dirname "$output_file")
    
    if [[ ! -d "$output_dir" ]]; then
        if ! mkdir -p "$output_dir" 2>/dev/null; then
            log_error "Failed to create monitoring output directory: $output_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on output directory
    if ! chmod 750 "$output_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on monitoring output directory"
    fi
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local monitoring_start_time
    monitoring_start_time=$(date +%s)
    
    # COMMENT: Monitor network interfaces
    log_info "Monitoring network interfaces"
    
    local network_interfaces
    network_interfaces=$(ip -o link show 2>/dev/null | awk '{print $2}' | cut -d: -f1 | grep -v lo || true)
    
    if [[ -n "$network_interfaces" ]]; then
        monitoring_results+=("Network interfaces: $(echo "$network_interfaces" | wc -l)")
        
        echo "$network_interfaces" | while read -r interface; do
            local interface_status
            interface_status=$(ip link show "$interface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2 || echo "UNKNOWN")
            monitoring_results+=("  $interface: $interface_status")
        done
    fi
    
    # COMMENT: Monitor network connections
    log_info "Monitoring network connections"
    
    local listening_ports
    listening_ports=$(netstat -tlnp 2>/dev/null | grep LISTEN || ss -tlnp 2>/dev/null | grep LISTEN || true)
    
    if [[ -n "$listening_ports" ]]; then
        local port_count
        port_count=$(echo "$listening_ports" | wc -l)
        monitoring_results+=("Listening ports: $port_count")
        
        if [[ "$monitoring_level" == "detailed" || "$monitoring_level" == "comprehensive" ]]; then
            monitoring_results+=("Port details:")
            echo "$listening_ports" | head -10 | while read -r line; do
                monitoring_results+=("  $line")
            done
        fi
    fi
    
    # COMMENT: Monitor network traffic
    if [[ "$monitoring_level" == "comprehensive" ]]; then
        log_info "Monitoring network traffic"
        
        # COMMENT: Get network statistics
        local network_stats
        network_stats=$(netstat -i 2>/dev/null | tail -n +3 || true)
        
        if [[ -n "$network_stats" ]]; then
            monitoring_results+=("Network statistics:")
            echo "$network_stats" | while read -r line; do
                monitoring_results+=("  $line")
            done
        fi
    fi
    
    # COMMENT: Monitor for specified duration
    local monitoring_end_time
    monitoring_end_time=$((monitoring_start_time + monitoring_duration))
    
    log_info "Monitoring network for ${monitoring_duration}s"
    
    while [[ $(date +%s) -lt $monitoring_end_time ]]; do
        # COMMENT: Basic network health check
        local connectivity_targets=("8.8.8.8" "1.1.1.1")
        
        for target in "${connectivity_targets[@]}"; do
            if test_network_connectivity "$target" >/dev/null 2>&1; then
                monitoring_results+=("Connectivity to $target: OK")
            else
                monitoring_results+=("Connectivity to $target: FAILED")
            fi
        done
        
        sleep "$NETWORK_MONITOR_INTERVAL"
    done
    
    # COMMENT: Calculate monitoring duration
    local actual_duration
    actual_duration=$(($(date +%s) - monitoring_start_time))
    
    # COMMENT: Generate monitoring summary
    local monitoring_summary="
=== NETWORK MONITORING SUMMARY ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $NETWORK_UTILS_ENVIRONMENT
Monitoring Level: $monitoring_level
Duration: ${actual_duration}s
Output File: $output_file

Monitoring Results:
$(printf "  - %s\n" "${monitoring_results[@]}")

Network monitoring completed successfully.
"
    
    # COMMENT: Write monitoring results to output file
    if echo "$monitoring_summary" > "$output_file" 2>/dev/null; then
        log_success "Network monitoring completed successfully in ${actual_duration}s"
        log_info "Monitoring results written to: $output_file"
        
        # COMMENT: Set secure permissions on output file
        if ! chmod 640 "$output_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on monitoring output file"
        fi
        
        return 0
    else
        log_error "Failed to write monitoring results to output file"
        return 1
    fi
}

# COMMENT: Production network diagnosis with validation
diagnose_network() {
    local target="$1"
    local diagnosis_type="${2:-comprehensive}"
    local output_file="${3:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$target" ]]; then
        log_error "Target not specified for network diagnosis"
        return 1
    fi
    
    if ! validate_ip_address "$target" && ! validate_hostname "$target"; then
        log_error "Invalid target format: $target"
        return 1
    fi
    
    case "$diagnosis_type" in
        basic|detailed|comprehensive)
            ;;
        *)
            log_error "Invalid diagnosis type: $diagnosis_type"
            return 1
            ;;
    esac
    
    log_info "Starting network diagnosis: $target (type: $diagnosis_type)"
    
    # COMMENT: Set output file if not specified
    if [[ -z "$output_file" ]]; then
        output_file="$SCRIPT_DIR/../logs/network_diagnosis_$(date +%Y%m%d_%H%M%S).log"
    fi
    
    # COMMENT: Create diagnosis output directory
    local output_dir
    output_dir=$(dirname "$output_file")
    
    if [[ ! -d "$output_dir" ]]; then
        if ! mkdir -p "$output_dir" 2>/dev/null; then
            log_error "Failed to create diagnosis output directory: $output_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on output directory
    if ! chmod 750 "$output_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on diagnosis output directory"
    fi
    
    # COMMENT: Initialize diagnosis results
    local diagnosis_results=()
    local diagnosis_start_time
    diagnosis_start_time=$(date +%s)
    
    # COMMENT: Basic connectivity test
    diagnosis_results+=("Basic connectivity test")
    if test_network_connectivity "$target" >/dev/null 2>&1; then
        diagnosis_results+=("  Basic connectivity: OK")
    else
        diagnosis_results+=("  Basic connectivity: FAILED")
    fi
    
    # COMMENT: DNS resolution test (for hostnames)
    if validate_hostname "$target"; then
        diagnosis_results+=("DNS resolution test")
        if nslookup "$target" >/dev/null 2>&1 || dig "$target" +short >/dev/null 2>&1; then
            diagnosis_results+=("  DNS resolution: OK")
        else
            diagnosis_results+=("  DNS resolution: FAILED")
        fi
    fi
    
    # COMMENT: Traceroute test
    if command -v traceroute >/dev/null 2>&1; then
        diagnosis_results+=("Traceroute test")
        local traceroute_output
        if traceroute_output=$(timeout 60 traceroute "$target" 2>/dev/null); then
            diagnosis_results+=("  Traceroute: OK")
            if [[ "$diagnosis_type" == "detailed" || "$diagnosis_type" == "comprehensive" ]]; then
                diagnosis_results+=("  Traceroute details:")
                echo "$traceroute_output" | while read -r line; do
                    diagnosis_results+=("    $line")
                done
            fi
        else
            diagnosis_results+=("  Traceroute: FAILED")
        fi
    fi
    
    # COMMENT: Port scan test
    if [[ "$diagnosis_type" == "comprehensive" ]]; then
        diagnosis_results+=("Port scan test")
        if scan_network_ports "$target" "80,443,22,53" "tcp" >/dev/null 2>&1; then
            diagnosis_results+=("  Port scan: OK")
        else
            diagnosis_results+=("  Port scan: FAILED")
        fi
    fi
    
    # COMMENT: Calculate diagnosis duration
    local diagnosis_end_time diagnosis_duration
    diagnosis_end_time=$(date +%s)
    diagnosis_duration=$((diagnosis_end_time - diagnosis_start_time))
    
    # COMMENT: Generate diagnosis summary
    local diagnosis_summary="
=== NETWORK DIAGNOSIS SUMMARY ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $NETWORK_UTILS_ENVIRONMENT
Target: $target
Diagnosis Type: $diagnosis_type
Duration: ${diagnosis_duration}s
Output File: $output_file

Diagnosis Results:
$(printf "  - %s\n" "${diagnosis_results[@]}")

Network diagnosis completed successfully.
"
    
    # COMMENT: Write diagnosis results to output file
    if echo "$diagnosis_summary" > "$output_file" 2>/dev/null; then
        log_success "Network diagnosis completed successfully in ${diagnosis_duration}s"
        log_info "Diagnosis results written to: $output_file"
        
        # COMMENT: Set secure permissions on output file
        if ! chmod 640 "$output_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on diagnosis output file"
        fi
        
        return 0
    else
        log_error "Failed to write diagnosis results to output file"
        return 1
    fi
}

# COMMENT: Production network configuration backup with validation
backup_network_config() {
    local backup_dir="$1"
    local backup_name="${2:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_dir" ]]; then
        backup_dir="$SCRIPT_DIR/../backups/network"
    fi
    
    # COMMENT: Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "Network configuration backup requires root privileges"
        return 1
    fi
    
    log_info "Starting network configuration backup: $backup_dir"
    
    # COMMENT: Validate backup directory
    if [[ ! -d "$backup_dir" ]]; then
        if ! mkdir -p "$backup_dir" 2>/dev/null; then
            log_error "Failed to create backup directory: $backup_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on backup directory
    if ! chmod 750 "$backup_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on backup directory"
    fi
    
    # COMMENT: Generate backup name if not provided
    if [[ -z "$backup_name" ]]; then
        local timestamp
        timestamp=$(date +%Y%m%d_%H%M%S)
        backup_name="network_config_backup_${timestamp}"
    fi
    
    # COMMENT: Create backup directory for this backup
    local config_backup_dir
    config_backup_dir="$backup_dir/$backup_name"
    
    if ! mkdir -p "$config_backup_dir" 2>/dev/null; then
        log_error "Failed to create config backup directory: $config_backup_dir"
        return 1
    fi
    
    # COMMENT: Set secure permissions on config backup directory
    if ! chmod 750 "$config_backup_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on config backup directory"
    fi
    
    # COMMENT: Backup network configuration files
    local config_files=(
        "/etc/network/interfaces"
        "/etc/netplan"
        "/etc/systemd/network"
        "/etc/resolv.conf"
        "/etc/hosts"
        "/etc/hostname"
    )
    
    for config_file in "${config_files[@]}"; do
        if [[ -e "$config_file" ]]; then
            local backup_file
            backup_file="$config_backup_dir/$(basename "$config_file")"
            
            if cp -r "$config_file" "$backup_file" 2>/dev/null; then
                # COMMENT: Set secure permissions on backup file
                if ! chmod 640 "$backup_file" 2>/dev/null; then
                    log_warning "Failed to set secure permissions on backup file: $backup_file"
                fi
                
                log_info "Backed up configuration: $config_file -> $backup_file"
            else
                log_warning "Failed to backup configuration: $config_file"
            fi
        fi
    done
    
    # COMMENT: Backup current network state
    local network_state_file
    network_state_file="$config_backup_dir/network_state.txt"
    
    local network_state="
=== NETWORK STATE BACKUP ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $NETWORK_UTILS_ENVIRONMENT

Network Interfaces:
$(ip -o link show 2>/dev/null || echo "Failed to get network interfaces")

IP Addresses:
$(ip -o addr show 2>/dev/null || echo "Failed to get IP addresses")

Routing Table:
$(ip route show 2>/dev/null || echo "Failed to get routing table")

Network Connections:
$(netstat -tlnp 2>/dev/null | head -20 || ss -tlnp 2>/dev/null | head -20 || echo "Failed to get network connections")
"
    
    if echo "$network_state" > "$network_state_file" 2>/dev/null; then
        # COMMENT: Set secure permissions on state file
        if ! chmod 640 "$network_state_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on network state file"
        fi
        
        log_info "Network state backed up: $network_state_file"
    else
        log_warning "Failed to backup network state"
    fi
    
    # COMMENT: Compress backup directory
    local compressed_backup
    compressed_backup="$backup_dir/${backup_name}.tar.gz"
    
    log_info "Compressing backup: $config_backup_dir -> $compressed_backup"
    
    if tar -czf "$compressed_backup" -C "$backup_dir" "$backup_name" 2>/dev/null; then
        # COMMENT: Set secure permissions on compressed backup
        if ! chmod 640 "$compressed_backup" 2>/dev/null; then
            log_warning "Failed to set secure permissions on compressed backup"
        fi
        
        log_success "Backup compressed: $compressed_backup"
        
        # COMMENT: Remove uncompressed backup directory
        if ! rm -rf "$config_backup_dir" 2>/dev/null; then
            log_warning "Failed to remove uncompressed backup directory"
        fi
        
        log_success "Network configuration backup completed successfully: $compressed_backup"
        return 0
    else
        log_error "Failed to compress backup: $config_backup_dir"
        return 1
    fi
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Network Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive network functions for production use.
    It includes connectivity testing, port scanning, configuration, and monitoring.

FUNCTIONS:
    validate_network_operation <operation> - Validate network operation
    validate_ip_address <ip> - Validate IP address format
    validate_hostname <hostname> - Validate hostname format
    validate_port <port> - Validate port number
    test_network_connectivity <target> [port] [timeout] [retries] - Test connectivity
    scan_network_ports <target> [range] [type] [output] - Scan network ports
    configure_network_interface <interface> <type> <value> - Configure interface
    monitor_network [level] [duration] [output] - Monitor network
    diagnose_network <target> [type] [output] - Diagnose network issues
    backup_network_config [dir] [name] - Backup network configuration

NETWORK OPERATIONS:
    test, scan, configure, monitor, diagnose, backup, restore

MONITORING LEVELS:
    basic, detailed, comprehensive

DIAGNOSIS TYPES:
    basic, detailed, comprehensive

SECURITY FEATURES:
    - Input validation and sanitization
    - IP address and hostname validation
    - Port number validation
    - Secure file permissions
    - Comprehensive error handling

EXAMPLES:
    source $SCRIPT_NAME
    test_network_connectivity "example.com" 80
    scan_network_ports "192.168.1.1" "1-1000" "tcp"
    monitor_network "detailed" 600
    diagnose_network "example.com" "comprehensive"
    backup_network_config "/backups" "network_backup"

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize network utilities if not already done
    if [[ -z "${NETWORK_UTILS_INITIALIZED:-}" ]]; then
        export NETWORK_UTILS_INITIALIZED="true"
        log_info "Network utilities initialized successfully"
    fi
    
    # COMMENT: Log successful loading
    log_info "Network utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
