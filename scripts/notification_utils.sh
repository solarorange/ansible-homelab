#!/bin/bash
# COMMENT: Production-ready Notification Utilities for Ansible Homelab
# COMMENT: Comprehensive notification handling with security validation and error handling
# COMMENT: Generated by: {{ ansible_managed }}
# COMMENT: Timestamp: {{ ansible_date_time.iso8601 }}
# COMMENT: Environment: {{ deployment_environment | default('production') }}

# COMMENT: Production security settings for notification reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="notification_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production notification configuration with security
NOTIFICATION_TYPES=("webhook" "email" "slack" "telegram" "discord" "mattermost")
DEFAULT_NOTIFICATION_TYPE="webhook"
NOTIFICATION_TIMEOUT=30
NOTIFICATION_RETRIES=3
NOTIFICATION_RETRY_DELAY=5

# COMMENT: Production environment variables with validation
export NOTIFICATION_UTILS_ENVIRONMENT="{{ deployment_environment | default('production') }}"
export NOTIFICATION_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Source logging utilities if available
if [[ -f "$SCRIPT_DIR/logging_utils.sh" ]]; then
    source "$SCRIPT_DIR/logging_utils.sh"
else
    # COMMENT: Fallback logging if utilities not available
    log_info() { echo "[INFO] $1"; }
    log_warning() { echo "[WARNING] $1" >&2; }
    log_error() { echo "[ERROR] $1" >&2; }
    log_success() { echo "[SUCCESS] $1"; }
fi

# COMMENT: Production notification validation with security
validate_notification_config() {
    local notification_type="$1"
    local config_data="$2"
    
    # COMMENT: Input validation for security
    if [[ -z "$notification_type" ]]; then
        log_error "Notification type not specified"
        return 1
    fi
    
    # COMMENT: Validate notification type
    case "$notification_type" in
        webhook|email|slack|telegram|discord|mattermost)
            ;;
        *)
            log_error "Invalid notification type: $notification_type"
            return 1
            ;;
    esac
    
    # COMMENT: Validate configuration data
    if [[ -z "$config_data" ]]; then
        log_error "Notification configuration data not provided"
        return 1
    fi
    
    # COMMENT: Type-specific validation
    case "$notification_type" in
        webhook)
            if ! echo "$config_data" | grep -q '"url"'; then
                log_error "Webhook configuration missing URL"
                return 1
            fi
            ;;
        email)
            if ! echo "$config_data" | grep -q '"smtp_host"'; then
                log_error "Email configuration missing SMTP host"
                return 1
            fi
            ;;
        slack)
            if ! echo "$config_data" | grep -q '"webhook_url"'; then
                log_error "Slack configuration missing webhook URL"
                return 1
            fi
            ;;
        telegram)
            if ! echo "$config_data" | grep -q '"bot_token"'; then
                log_error "Telegram configuration missing bot token"
                return 1
            fi
            ;;
    esac
    
    log_info "Notification configuration validation passed for type: $notification_type"
    return 0
}

# COMMENT: Production webhook notification with security validation
send_webhook_notification() {
    local webhook_url="$1"
    local message="$2"
    local headers="${3:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$webhook_url" ]]; then
        log_error "Webhook URL not specified"
        return 1
    fi
    
    if [[ -z "$message" ]]; then
        log_error "Webhook message not specified"
        return 1
    fi
    
    # COMMENT: Validate webhook URL format
    if ! echo "$webhook_url" | grep -E '^https?://' >/dev/null; then
        log_error "Invalid webhook URL format: $webhook_url"
        return 1
    fi
    
    # COMMENT: Sanitize message for security
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Prepare curl command with security options
    local curl_cmd="curl -s -X POST"
    curl_cmd="$curl_cmd --max-time $NOTIFICATION_TIMEOUT"
    curl_cmd="$curl_cmd --retry $NOTIFICATION_RETRIES"
    curl_cmd="$curl_cmd --retry-delay $NOTIFICATION_RETRY_DELAY"
    curl_cmd="$curl_cmd -H 'Content-Type: application/json'"
    
    # COMMENT: Add custom headers if provided
    if [[ -n "$headers" ]]; then
        curl_cmd="$curl_cmd -H '$headers'"
    fi
    
    # COMMENT: Add webhook URL and message
    curl_cmd="$curl_cmd -d '$message'"
    curl_cmd="$curl_cmd '$webhook_url'"
    
    # COMMENT: Execute webhook notification
    log_info "Sending webhook notification to: $webhook_url"
    
    if eval "$curl_cmd" >/dev/null 2>&1; then
        log_success "Webhook notification sent successfully"
        return 0
    else
        log_error "Failed to send webhook notification"
        return 1
    fi
}

# COMMENT: Production email notification with security validation
send_email_notification() {
    local smtp_host="$1"
    local smtp_port="$2"
    local smtp_username="$3"
    local smtp_password="$4"
    local from_address="$5"
    local to_address="$6"
    local subject="$7"
    local message="$8"
    
    # COMMENT: Input validation for security
    if [[ -z "$smtp_host" || -z "$smtp_port" || -z "$from_address" || -z "$to_address" ]]; then
        log_error "Required email parameters not specified"
        return 1
    fi
    
    # COMMENT: Validate email addresses
    if ! echo "$from_address" | grep -E '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' >/dev/null; then
        log_error "Invalid from address format: $from_address"
        return 1
    fi
    
    if ! echo "$to_address" | grep -E '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' >/dev/null; then
        log_error "Invalid to address format: $to_address"
        return 1
    fi
    
    # COMMENT: Sanitize inputs for security
    subject=$(echo "$subject" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Check if sendmail is available
    if ! command -v sendmail >/dev/null 2>&1; then
        log_error "sendmail command not available"
        return 1
    fi
    
    # COMMENT: Create email content
    local email_content="From: $from_address
To: $to_address
Subject: $subject
Content-Type: text/plain; charset=UTF-8

$message"
    
    # COMMENT: Send email using sendmail
    log_info "Sending email notification to: $to_address"
    
    if echo "$email_content" | sendmail -t; then
        log_success "Email notification sent successfully"
        return 0
    else
        log_error "Failed to send email notification"
        return 1
    fi
}

# COMMENT: Production Slack notification with security validation
send_slack_notification() {
    local webhook_url="$1"
    local channel="$2"
    local username="$3"
    local message="$4"
    
    # COMMENT: Input validation for security
    if [[ -z "$webhook_url" ]]; then
        log_error "Slack webhook URL not specified"
        return 1
    fi
    
    if [[ -z "$message" ]]; then
        log_error "Slack message not specified"
        return 1
    fi
    
    # COMMENT: Validate webhook URL format
    if ! echo "$webhook_url" | grep -E '^https://hooks\.slack\.com/' >/dev/null; then
        log_error "Invalid Slack webhook URL format: $webhook_url"
        return 1
    fi
    
    # COMMENT: Sanitize inputs for security
    channel=$(echo "$channel" | sed 's/[^a-zA-Z0-9_\-]/_/g')
    username=$(echo "$username" | sed 's/[^a-zA-Z0-9_\-]/_/g')
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Prepare Slack payload
    local slack_payload="{
        \"text\": \"$message\",
        \"channel\": \"$channel\",
        \"username\": \"$username\"
    }"
    
    # COMMENT: Send Slack notification
    log_info "Sending Slack notification to channel: $channel"
    
    if send_webhook_notification "$webhook_url" "$slack_payload"; then
        log_success "Slack notification sent successfully"
        return 0
    else
        log_error "Failed to send Slack notification"
        return 1
    fi
}

# COMMENT: Production Telegram notification with security validation
send_telegram_notification() {
    local bot_token="$1"
    local chat_id="$2"
    local message="$3"
    
    # COMMENT: Input validation for security
    if [[ -z "$bot_token" ]]; then
        log_error "Telegram bot token not specified"
        return 1
    fi
    
    if [[ -z "$chat_id" ]]; then
        log_error "Telegram chat ID not specified"
        return 1
    fi
    
    if [[ -z "$message" ]]; then
        log_error "Telegram message not specified"
        return 1
    fi
    
    # COMMENT: Validate bot token format
    if ! echo "$bot_token" | grep -E '^[0-9]+:[a-zA-Z0-9_-]+$' >/dev/null; then
        log_error "Invalid Telegram bot token format"
        return 1
    fi
    
    # COMMENT: Validate chat ID format
    if ! echo "$chat_id" | grep -E '^[0-9-]+$' >/dev/null; then
        log_error "Invalid Telegram chat ID format: $chat_id"
        return 1
    fi
    
    # COMMENT: Sanitize message for security
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Prepare Telegram API URL
    local telegram_url="https://api.telegram.org/bot$bot_token/sendMessage"
    
    # COMMENT: Prepare Telegram payload
    local telegram_payload="{
        \"chat_id\": \"$chat_id\",
        \"text\": \"$message\",
        \"parse_mode\": \"Markdown\"
    }"
    
    # COMMENT: Send Telegram notification
    log_info "Sending Telegram notification to chat: $chat_id"
    
    if send_webhook_notification "$telegram_url" "$telegram_payload"; then
        log_success "Telegram notification sent successfully"
        return 0
    else
        log_error "Failed to send Telegram notification"
        return 1
    fi
}

# COMMENT: Production Discord notification with security validation
send_discord_notification() {
    local webhook_url="$1"
    local username="$2"
    local message="$3"
    
    # COMMENT: Input validation for security
    if [[ -z "$webhook_url" ]]; then
        log_error "Discord webhook URL not specified"
        return 1
    fi
    
    if [[ -z "$message" ]]; then
        log_error "Discord message not specified"
        return 1
    fi
    
    # COMMENT: Validate webhook URL format
    if ! echo "$webhook_url" | grep -E '^https://discord\.com/api/webhooks/' >/dev/null; then
        log_error "Invalid Discord webhook URL format: $webhook_url"
        return 1
    fi
    
    # COMMENT: Sanitize inputs for security
    username=$(echo "$username" | sed 's/[^a-zA-Z0-9_\-]/_/g')
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Prepare Discord payload
    local discord_payload="{
        \"username\": \"$username\",
        \"content\": \"$message\"
    }"
    
    # COMMENT: Send Discord notification
    log_info "Sending Discord notification as: $username"
    
    if send_webhook_notification "$webhook_url" "$discord_payload"; then
        log_success "Discord notification sent successfully"
        return 0
    else
        log_error "Failed to send Discord notification"
        return 1
    fi
}

# COMMENT: Production Mattermost notification with security validation
send_mattermost_notification() {
    local webhook_url="$1"
    local username="$2"
    local message="$3"
    
    # COMMENT: Input validation for security
    if [[ -z "$webhook_url" ]]; then
        log_error "Mattermost webhook URL not specified"
        return 1
    fi
    
    if [[ -z "$message" ]]; then
        log_error "Mattermost message not specified"
        return 1
    fi
    
    # COMMENT: Validate webhook URL format
    if ! echo "$webhook_url" | grep -E '^https?://.*/hooks/' >/dev/null; then
        log_error "Invalid Mattermost webhook URL format: $webhook_url"
        return 1
    fi
    
    # COMMENT: Sanitize inputs for security
    username=$(echo "$username" | sed 's/[^a-zA-Z0-9_\-]/_/g')
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Prepare Mattermost payload
    local mattermost_payload="{
        \"username\": \"$username\",
        \"text\": \"$message\"
    }"
    
    # COMMENT: Send Mattermost notification
    log_info "Sending Mattermost notification as: $username"
    
    if send_webhook_notification "$webhook_url" "$mattermost_payload"; then
        log_success "Mattermost notification sent successfully"
        return 0
    else
        log_error "Failed to send Mattermost notification"
        return 1
    fi
}

# COMMENT: Production generic notification dispatcher with security validation
send_notification() {
    local notification_type="$1"
    local config_data="$2"
    local message="$3"
    
    # COMMENT: Input validation for security
    if [[ -z "$notification_type" ]]; then
        log_error "Notification type not specified"
        return 1
    fi
    
    if [[ -z "$config_data" ]]; then
        log_error "Notification configuration not specified"
        return 1
    fi
    
    if [[ -z "$message" ]]; then
        log_error "Notification message not specified"
        return 1
    fi
    
    # COMMENT: Validate notification configuration
    if ! validate_notification_config "$notification_type" "$config_data"; then
        log_error "Notification configuration validation failed"
        return 1
    fi
    
    # COMMENT: Parse configuration data
    local config_json
    if ! config_json=$(echo "$config_data" | python3 -m json.tool 2>/dev/null); then
        log_error "Invalid notification configuration JSON format"
        return 1
    fi
    
    # COMMENT: Dispatch to appropriate notification function
    case "$notification_type" in
        webhook)
            local webhook_url
            webhook_url=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin)['url'])" 2>/dev/null)
            if [[ -n "$webhook_url" ]]; then
                send_webhook_notification "$webhook_url" "$message"
            else
                log_error "Webhook URL not found in configuration"
                return 1
            fi
            ;;
        email)
            local smtp_host smtp_port smtp_username smtp_password from_address to_address
            smtp_host=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('smtp_host', ''))" 2>/dev/null)
            smtp_port=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('smtp_port', '587'))" 2>/dev/null)
            smtp_username=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('smtp_username', ''))" 2>/dev/null)
            smtp_password=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('smtp_password', ''))" 2>/dev/null)
            from_address=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('from_address', ''))" 2>/dev/null)
            to_address=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('to_address', ''))" 2>/dev/null)
            
            if [[ -n "$smtp_host" && -n "$from_address" && -n "$to_address" ]]; then
                send_email_notification "$smtp_host" "$smtp_port" "$smtp_username" "$smtp_password" "$from_address" "$to_address" "Homelab Notification" "$message"
            else
                log_error "Required email configuration not found"
                return 1
            fi
            ;;
        slack)
            local webhook_url channel username
            webhook_url=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin)['webhook_url'])" 2>/dev/null)
            channel=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('channel', '#general'))" 2>/dev/null)
            username=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('username', 'HomelabBot'))" 2>/dev/null)
            
            if [[ -n "$webhook_url" ]]; then
                send_slack_notification "$webhook_url" "$channel" "$username" "$message"
            else
                log_error "Slack webhook URL not found in configuration"
                return 1
            fi
            ;;
        telegram)
            local bot_token chat_id
            bot_token=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin)['bot_token'])" 2>/dev/null)
            chat_id=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin)['chat_id'])" 2>/dev/null)
            
            if [[ -n "$bot_token" && -n "$chat_id" ]]; then
                send_telegram_notification "$bot_token" "$chat_id" "$message"
            else
                log_error "Required Telegram configuration not found"
                return 1
            fi
            ;;
        discord)
            local webhook_url username
            webhook_url=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin)['webhook_url'])" 2>/dev/null)
            username=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('username', 'HomelabBot'))" 2>/dev/null)
            
            if [[ -n "$webhook_url" ]]; then
                send_discord_notification "$webhook_url" "$username" "$message"
            else
                log_error "Discord webhook URL not found in configuration"
                return 1
            fi
            ;;
        mattermost)
            local webhook_url username
            webhook_url=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin)['webhook_url'])" 2>/dev/null)
            username=$(echo "$config_json" | python3 -c "import sys, json; print(json.load(sys.stdin).get('username', 'HomelabBot'))" 2>/dev/null)
            
            if [[ -n "$webhook_url" ]]; then
                send_mattermost_notification "$webhook_url" "$username" "$message"
            else
                log_error "Mattermost webhook URL not found in configuration"
                return 1
            fi
            ;;
        *)
            log_error "Unsupported notification type: $notification_type"
            return 1
            ;;
    esac
}

# COMMENT: Production notification test with security validation
test_notification() {
    local notification_type="$1"
    local config_data="$2"
    
    # COMMENT: Input validation for security
    if [[ -z "$notification_type" ]]; then
        log_error "Notification type not specified for testing"
        return 1
    fi
    
    if [[ -z "$config_data" ]]; then
        log_error "Notification configuration not specified for testing"
        return 1
    fi
    
    # COMMENT: Create test message
    local test_message="{
        \"text\": \"Test notification from Homelab deployment system\",
        \"timestamp\": \"$(date -u '+%Y-%m-%d %H:%M:%S UTC')\",
        \"environment\": \"$NOTIFICATION_UTILS_ENVIRONMENT\",
        \"type\": \"test\"
    }"
    
    # COMMENT: Send test notification
    log_info "Testing $notification_type notification"
    
    if send_notification "$notification_type" "$config_data" "$test_message"; then
        log_success "$notification_type notification test passed"
        return 0
    else
        log_error "$notification_type notification test failed"
        return 1
    fi
}

# COMMENT: Production notification configuration validation with security
validate_notification_setup() {
    local config_file="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$config_file" ]]; then
        log_error "Notification configuration file not specified"
        return 1
    fi
    
    if [[ ! -f "$config_file" ]]; then
        log_error "Notification configuration file not found: $config_file"
        return 1
    fi
    
    # COMMENT: Validate configuration file permissions
    local permissions
    permissions=$(stat -c "%a" "$config_file" 2>/dev/null || stat -f "%Lp" "$config_file" 2>/dev/null)
    
    if [[ -z "$permissions" ]]; then
        log_error "Cannot read configuration file permissions"
        return 1
    fi
    
    # COMMENT: Check if permissions are secure (600 or more restrictive)
    if [[ "$permissions" != "6"* ]]; then
        log_warning "Configuration file has insecure permissions: $permissions (should be 600)"
    fi
    
    # COMMENT: Validate JSON format
    if ! python3 -m json.tool "$config_file" >/dev/null 2>&1; then
        log_error "Invalid JSON format in configuration file"
        return 1
    fi
    
    # COMMENT: Parse and validate configuration
    local config_data
    config_data=$(cat "$config_file")
    
    # COMMENT: Check for required fields
    if ! echo "$config_data" | python3 -c "import sys, json; data=json.load(sys.stdin); print('type' in data and 'config' in data)" 2>/dev/null | grep -q "True"; then
        log_error "Configuration file missing required fields: type, config"
        return 1
    fi
    
    # COMMENT: Extract notification type and config
    local notification_type config
    notification_type=$(echo "$config_data" | python3 -c "import sys, json; print(json.load(sys.stdin)['type'])" 2>/dev/null)
    config=$(echo "$config_data" | python3 -c "import sys, json; print(json.dumps(json.load(sys.stdin)['config']))" 2>/dev/null)
    
    # COMMENT: Validate notification configuration
    if ! validate_notification_config "$notification_type" "$config"; then
        log_error "Notification configuration validation failed"
        return 1
    fi
    
    log_success "Notification configuration validation passed"
    return 0
}

# COMMENT: Production notification initialization with security validation
init_notifications() {
    local config_file="${1:-}"
    local test_notifications="${2:-false}"
    
    # COMMENT: Set default configuration if not specified
    if [[ -z "$config_file" ]]; then
        config_file="$SCRIPT_DIR/../config/notifications.json"
    fi
    
    # COMMENT: Check if configuration file exists
    if [[ ! -f "$config_file" ]]; then
        log_warning "Notification configuration file not found: $config_file (notifications disabled)"
        return 0
    fi
    
    # COMMENT: Validate notification setup
    if ! validate_notification_setup "$config_file"; then
        log_error "Notification setup validation failed"
        return 1
    fi
    
    # COMMENT: Test notifications if requested
    if [[ "$test_notifications" == "true" ]]; then
        log_info "Testing notification configuration"
        
        local config_data
        config_data=$(cat "$config_file")
        
        local notification_type config
        notification_type=$(echo "$config_data" | python3 -c "import sys, json; print(json.load(sys.stdin)['type'])" 2>/dev/null)
        config=$(echo "$config_data" | python3 -c "import sys, json; print(json.dumps(json.load(sys.stdin)['config']))" 2>/dev/null)
        
        if ! test_notification "$notification_type" "$config"; then
            log_warning "Notification test failed - notifications may not work"
        fi
    fi
    
    log_success "Notifications initialized successfully"
    return 0
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Notification Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive notification functions for production use.
    It includes security validation, multiple notification channels, and error handling.

FUNCTIONS:
    send_notification <type> <config> <message> - Send notification with configuration
    send_webhook_notification <url> <message> [headers] - Send webhook notification
    send_email_notification <smtp_host> <port> <username> <password> <from> <to> <subject> <message> - Send email
    send_slack_notification <webhook_url> <channel> <username> <message> - Send Slack notification
    send_telegram_notification <bot_token> <chat_id> <message> - Send Telegram notification
    send_discord_notification <webhook_url> <username> <message> - Send Discord notification
    send_mattermost_notification <webhook_url> <username> <message> - Send Mattermost notification

UTILITY FUNCTIONS:
    validate_notification_config <type> <config> - Validate notification configuration
    test_notification <type> <config> - Test notification configuration
    validate_notification_setup <config_file> - Validate notification setup
    init_notifications [config_file] [test] - Initialize notification system

SUPPORTED TYPES:
    webhook, email, slack, telegram, discord, mattermost

SECURITY FEATURES:
    - Input validation and sanitization
    - URL format validation
    - Configuration file permission checks
    - Secure notification delivery
    - Error handling and logging

EXAMPLES:
    source $SCRIPT_NAME
    init_notifications "/path/to/config.json" "true"
    send_notification "webhook" '{"url":"https://example.com/webhook"}' "Deployment completed"
    test_notification "slack" '{"webhook_url":"https://hooks.slack.com/..."}'

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize notifications if not already done
    if [[ -z "${NOTIFICATIONS_INITIALIZED:-}" ]]; then
        if init_notifications; then
            export NOTIFICATIONS_INITIALIZED="true"
        else
            log_warning "Failed to initialize notifications - some functions may not work"
        fi
    fi
    
    # COMMENT: Log successful loading
    log_info "Notification utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
