#!/bin/bash
# COMMENT: Production-ready Monitoring Utilities for Ansible Homelab
# COMMENT: Comprehensive monitoring, health checks, and alerting functions
# COMMENT: Generated by: {{ ansible_managed }}
# COMMENT: Timestamp: {{ ansible_date_time.iso8601 }}
# COMMENT: Environment: {{ deployment_environment | default('production') }}

# COMMENT: Production security settings for monitoring utility reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="monitoring_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production monitoring configuration with validation
MONITORING_TYPES=("system" "service" "network" "database" "application" "custom")
DEFAULT_MONITORING_TYPE="system"
MONITORING_TIMEOUT=30
MONITORING_RETRIES=3
MONITORING_RETRY_DELAY=5
HEALTH_CHECK_INTERVAL=60
ALERT_THRESHOLD_CRITICAL=90
ALERT_THRESHOLD_WARNING=75

# COMMENT: Production environment variables with validation
export MONITORING_UTILS_ENVIRONMENT="{{ deployment_environment | default('production') }}"
export MONITORING_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Source logging utilities if available
if [[ -f "$SCRIPT_DIR/logging_utils.sh" ]]; then
    source "$SCRIPT_DIR/logging_utils.sh"
else
    # COMMENT: Fallback logging if utilities not available
    log_info() { echo "[INFO] $1"; }
    log_warning() { echo "[WARNING] $1" >&2; }
    log_error() { echo "[ERROR] $1" >&2; }
    log_success() { echo "[SUCCESS] $1"; }
fi

# COMMENT: Source notification utilities if available
if [[ -f "$SCRIPT_DIR/notification_utils.sh" ]]; then
    source "$SCRIPT_DIR/notification_utils.sh"
else
    # COMMENT: Fallback notification if utilities not available
    send_notification() { log_warning "Notification utilities not available: $1"; }
fi

# COMMENT: Production monitoring type validation with security
validate_monitoring_type() {
    local monitoring_type="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$monitoring_type" ]]; then
        log_error "Monitoring type not specified"
        return 1
    fi
    
    # COMMENT: Validate monitoring type
    case "$monitoring_type" in
        system|service|network|database|application|custom)
            return 0
            ;;
        *)
            log_error "Invalid monitoring type: $monitoring_type"
            return 1
            ;;
    esac
}

# COMMENT: Production system resource monitoring with validation
monitor_system_resources() {
    local monitoring_level="${1:-basic}"
    
    # COMMENT: Input validation for security
    case "$monitoring_level" in
        basic|detailed|comprehensive)
            ;;
        *)
            log_error "Invalid monitoring level: $monitoring_level"
            return 1
            ;;
    esac
    
    log_info "Starting system resource monitoring (level: $monitoring_level)"
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local critical_alerts=()
    local warning_alerts=()
    
    # COMMENT: Monitor CPU usage
    local cpu_usage
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 2>/dev/null || echo "0")
    
    if [[ -n "$cpu_usage" && "$cpu_usage" != "0" ]]; then
        if [[ "$cpu_usage" -ge "$ALERT_THRESHOLD_CRITICAL" ]]; then
            critical_alerts+=("CPU usage critical: ${cpu_usage}%")
        elif [[ "$cpu_usage" -ge "$ALERT_THRESHOLD_WARNING" ]]; then
            warning_alerts+=("CPU usage warning: ${cpu_usage}%")
        fi
        
        monitoring_results+=("CPU: ${cpu_usage}%")
    fi
    
    # COMMENT: Monitor memory usage
    local memory_info
    memory_info=$(free -m 2>/dev/null | grep "Mem:" || true)
    
    if [[ -n "$memory_info" ]]; then
        local total_memory used_memory memory_percentage
        total_memory=$(echo "$memory_info" | awk '{print $2}')
        used_memory=$(echo "$memory_info" | awk '{print $3}')
        
        if [[ "$total_memory" -gt 0 ]]; then
            memory_percentage=$((used_memory * 100 / total_memory))
            
            if [[ "$memory_percentage" -ge "$ALERT_THRESHOLD_CRITICAL" ]]; then
                critical_alerts+=("Memory usage critical: ${memory_percentage}%")
            elif [[ "$memory_percentage" -ge "$ALERT_THRESHOLD_WARNING" ]]; then
                warning_alerts+=("Memory usage warning: ${memory_percentage}%")
            fi
            
            monitoring_results+=("Memory: ${memory_percentage}% (${used_memory}M/${total_memory}M)")
        fi
    fi
    
    # COMMENT: Monitor disk usage
    local disk_usage
    disk_usage=$(df -h / 2>/dev/null | tail -1 | awk '{print $5}' | cut -d'%' -f1 || echo "0")
    
    if [[ -n "$disk_usage" && "$disk_usage" != "0" ]]; then
        if [[ "$disk_usage" -ge "$ALERT_THRESHOLD_CRITICAL" ]]; then
            critical_alerts+=("Disk usage critical: ${disk_usage}%")
        elif [[ "$disk_usage" -ge "$ALERT_THRESHOLD_WARNING" ]]; then
            warning_alerts+=("Disk usage warning: ${disk_usage}%")
        fi
        
        monitoring_results+=("Disk: ${disk_usage}%")
    fi
    
    # COMMENT: Detailed monitoring if requested
    if [[ "$monitoring_level" == "detailed" || "$monitoring_level" == "comprehensive" ]]; then
        # COMMENT: Monitor load average
        local load_average
        load_average=$(uptime 2>/dev/null | awk -F'load average:' '{print $2}' | awk '{print $1}' | cut -d',' -f1 || echo "0")
        
        if [[ -n "$load_average" && "$load_average" != "0" ]]; then
            local cpu_cores
            cpu_cores=$(nproc 2>/dev/null || echo "1")
            local load_percentage
            load_percentage=$(echo "scale=2; $load_average * 100 / $cpu_cores" | bc 2>/dev/null || echo "0")
            
            if [[ "$load_percentage" -ge "$ALERT_THRESHOLD_CRITICAL" ]]; then
                critical_alerts+=("Load average critical: ${load_average} (${load_percentage}%)")
            elif [[ "$load_percentage" -ge "$ALERT_THRESHOLD_WARNING" ]]; then
                warning_alerts+=("Load average warning: ${load_average} (${load_percentage}%)")
            fi
            
            monitoring_results+=("Load: ${load_average} (${load_percentage}%)")
        fi
        
        # COMMENT: Monitor network interfaces
        local network_interfaces
        network_interfaces=$(ip -o link show 2>/dev/null | awk '{print $2}' | cut -d: -f1 | grep -v lo || true)
        
        if [[ -n "$network_interfaces" ]]; then
            monitoring_results+=("Network interfaces: $(echo "$network_interfaces" | wc -l)")
            
            echo "$network_interfaces" | while read -r interface; do
                local interface_status
                interface_status=$(ip link show "$interface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2 || echo "UNKNOWN")
                monitoring_results+=("  $interface: $interface_status")
            done
        fi
    fi
    
    # COMMENT: Comprehensive monitoring if requested
    if [[ "$monitoring_level" == "comprehensive" ]]; then
        # COMMENT: Monitor system uptime
        local uptime_info
        uptime_info=$(uptime -p 2>/dev/null | sed 's/up //' || echo "unknown")
        monitoring_results+=("Uptime: $uptime_info")
        
        # COMMENT: Monitor active processes
        local process_count
        process_count=$(ps aux 2>/dev/null | wc -l || echo "0")
        monitoring_results+=("Active processes: $process_count")
        
        # COMMENT: Monitor system temperature if available
        if command -v sensors >/dev/null 2>&1; then
            local temperature_info
            temperature_info=$(sensors 2>/dev/null | grep -E "Core|temp" | head -3 || true)
            
            if [[ -n "$temperature_info" ]]; then
                monitoring_results+=("Temperature sensors:")
                echo "$temperature_info" | while read -r temp; do
                    monitoring_results+=("  $temp")
                done
            fi
        fi
    fi
    
    # COMMENT: Log monitoring results
    log_info "System resource monitoring results:"
    for result in "${monitoring_results[@]}"; do
        log_info "  $result"
    done
    
    # COMMENT: Handle alerts
    if [[ ${#critical_alerts[@]} -gt 0 ]]; then
        log_error "Critical system alerts detected:"
        for alert in "${critical_alerts[@]}"; do
            log_error "  $alert"
        done
        
        # COMMENT: Send critical alert notification
        local alert_message="Critical system alerts detected on $(hostname): $(printf '%s; ' "${critical_alerts[@]}")"
        send_notification "webhook" '{"url":"{{ vault_notification_webhook_url | default("") }}"} ' "$alert_message" || true
    fi
    
    if [[ ${#warning_alerts[@]} -gt 0 ]]; then
        log_warning "Warning system alerts detected:"
        for alert in "${warning_alerts[@]}"; do
            log_warning "  $alert"
        done
    fi
    
    # COMMENT: Return status based on alerts
    if [[ ${#critical_alerts[@]} -gt 0 ]]; then
        return 2  # COMMENT: Critical status
    elif [[ ${#warning_alerts[@]} -gt 0 ]]; then
        return 1  # COMMENT: Warning status
    else
        log_success "System resource monitoring completed - all systems normal"
        return 0  # COMMENT: Normal status
    fi
}

# COMMENT: Production service monitoring with validation
monitor_services() {
    local service_list="${1:-}"
    local monitoring_timeout="${2:-$MONITORING_TIMEOUT}"
    
    # COMMENT: Input validation for security
    if [[ -z "$service_list" ]]; then
        # COMMENT: Default critical services
        service_list="docker ssh ufw fail2ban"
    fi
    
    log_info "Starting service monitoring: $service_list"
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local failed_services=()
    local warning_services=()
    
    # COMMENT: Parse service list
    local services
    IFS=' ' read -ra services <<< "$service_list"
    
    for service in "${services[@]}"; do
        # COMMENT: Sanitize service name for security
        service=$(echo "$service" | sed 's/[^a-zA-Z0-9_-]/_/g')
        
        if [[ -z "$service" ]]; then
            continue
        fi
        
        log_info "Monitoring service: $service"
        
        # COMMENT: Check service status
        local service_status
        if command -v systemctl >/dev/null 2>&1; then
            # COMMENT: Use systemctl for systemd services
            if systemctl is-active --quiet "$service" 2>/dev/null; then
                service_status="active"
            elif systemctl is-enabled --quiet "$service" 2>/dev/null; then
                service_status="enabled"
            else
                service_status="inactive"
            fi
        elif command -v service >/dev/null 2>&1; then
            # COMMENT: Use service command for init.d services
            if service "$service" status >/dev/null 2>&1; then
                service_status="running"
            else
                service_status="stopped"
            fi
        else
            # COMMENT: Fallback to process check
            if pgrep -x "$service" >/dev/null 2>&1; then
                service_status="running"
            else
                service_status="not_found"
            fi
        fi
        
        # COMMENT: Evaluate service status
        case "$service_status" in
            active|running|enabled)
                monitoring_results+=("$service: $service_status")
                ;;
            inactive|stopped)
                failed_services+=("$service: $service_status")
                ;;
            *)
                warning_services+=("$service: $service_status")
                ;;
        esac
    done
    
    # COMMENT: Log monitoring results
    log_info "Service monitoring results:"
    for result in "${monitoring_results[@]}"; do
        log_info "  $result"
    done
    
    # COMMENT: Handle failed services
    if [[ ${#failed_services[@]} -gt 0 ]]; then
        log_error "Failed services detected:"
        for service in "${failed_services[@]}"; do
            log_error "  $service"
        done
        
        # COMMENT: Send failure alert notification
        local alert_message="Service failures detected on $(hostname): $(printf '%s; ' "${failed_services[@]}")"
        send_notification "webhook" '{"url":"{{ vault_notification_webhook_url | default("") }}"} ' "$alert_message" || true
    fi
    
    # COMMENT: Handle warning services
    if [[ ${#warning_services[@]} -gt 0 ]]; then
        log_warning "Warning services detected:"
        for service in "${warning_services[@]}"; do
            log_warning "  $service"
        done
    fi
    
    # COMMENT: Return status based on service health
    if [[ ${#failed_services[@]} -gt 0 ]]; then
        return 2  # COMMENT: Critical status
    elif [[ ${#warning_services[@]} -gt 0 ]]; then
        return 1  # COMMENT: Warning status
    else
        log_success "Service monitoring completed - all services healthy"
        return 0  # COMMENT: Normal status
    fi
}

# COMMENT: Production network monitoring with validation
monitor_network() {
    local monitoring_level="${1:-basic}"
    
    # COMMENT: Input validation for security
    case "$monitoring_level" in
        basic|detailed|comprehensive)
            ;;
        *)
            log_error "Invalid network monitoring level: $monitoring_level"
            return 1
            ;;
    esac
    
    log_info "Starting network monitoring (level: $monitoring_level)"
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local network_issues=()
    
    # COMMENT: Monitor network connectivity
    local connectivity_targets=("8.8.8.8" "1.1.1.1" "{{ ansible_default_ipv4.gateway | default('8.8.8.8') }}")
    
    for target in "${connectivity_targets[@]}"; do
        # COMMENT: Sanitize target for security
        target=$(echo "$target" | sed 's/[^0-9.]//g')
        
        if [[ -z "$target" ]]; then
            continue
        fi
        
        log_info "Testing connectivity to: $target"
        
        if ping -c 1 -W 5 "$target" >/dev/null 2>&1; then
            monitoring_results+=("Connectivity to $target: OK")
        else
            network_issues+=("Connectivity to $target: FAILED")
        fi
    done
    
    # COMMENT: Monitor listening ports
    local listening_ports
    listening_ports=$(netstat -tlnp 2>/dev/null | grep LISTEN || ss -tlnp 2>/dev/null | grep LISTEN || true)
    
    if [[ -n "$listening_ports" ]]; then
        local port_count
        port_count=$(echo "$listening_ports" | wc -l)
        monitoring_results+=("Listening ports: $port_count")
        
        if [[ "$monitoring_level" == "detailed" || "$monitoring_level" == "comprehensive" ]]; then
            monitoring_results+=("Port details:")
            echo "$listening_ports" | head -10 | while read -r line; do
                monitoring_results+=("  $line")
            done
        fi
    fi
    
    # COMMENT: Monitor network interfaces
    local network_interfaces
    network_interfaces=$(ip -o addr show 2>/dev/null | grep -v "127.0.0.1" | grep -v "::1" || true)
    
    if [[ -n "$network_interfaces" ]]; then
        local interface_count
        interface_count=$(echo "$network_interfaces" | wc -l)
        monitoring_results+=("Active network interfaces: $interface_count")
        
        if [[ "$monitoring_level" == "comprehensive" ]]; then
            monitoring_results+=("Interface details:")
            echo "$network_interfaces" | while read -r line; do
                monitoring_results+=("  $line")
            done
        fi
    fi
    
    # COMMENT: Monitor DNS resolution
    local dns_targets=("google.com" "github.com" "{{ ansible_domain | default('example.com') }}")
    
    for target in "${dns_targets[@]}"; do
        # COMMENT: Sanitize target for security
        target=$(echo "$target" | sed 's/[^a-zA-Z0-9.-]/_/g')
        
        if [[ -z "$target" ]]; then
            continue
        fi
        
        log_info "Testing DNS resolution for: $target"
        
        if nslookup "$target" >/dev/null 2>&1 || dig "$target" +short >/dev/null 2>&1; then
            monitoring_results+=("DNS resolution for $target: OK")
        else
            network_issues+=("DNS resolution for $target: FAILED")
        fi
    done
    
    # COMMENT: Log monitoring results
    log_info "Network monitoring results:"
    for result in "${monitoring_results[@]}"; do
        log_info "  $result"
    done
    
    # COMMENT: Handle network issues
    if [[ ${#network_issues[@]} -gt 0 ]]; then
        log_error "Network issues detected:"
        for issue in "${network_issues[@]}"; do
            log_error "  $issue"
        done
        
        # COMMENT: Send network alert notification
        local alert_message="Network issues detected on $(hostname): $(printf '%s; ' "${network_issues[@]}")"
        send_notification "webhook" '{"url":"{{ vault_notification_webhook_url | default("") }}"} ' "$alert_message" || true
    fi
    
    # COMMENT: Return status based on network health
    if [[ ${#network_issues[@]} -gt 0 ]]; then
        return 2  # COMMENT: Critical status
    else
        log_success "Network monitoring completed - all systems normal"
        return 0  # COMMENT: Normal status
    fi
}

# COMMENT: Production database monitoring with validation
monitor_databases() {
    local database_list="${1:-}"
    local monitoring_timeout="${2:-$MONITORING_TIMEOUT}"
    
    # COMMENT: Input validation for security
    if [[ -z "$database_list" ]]; then
        # COMMENT: Default database services
        database_list="postgresql mysql redis"
    fi
    
    log_info "Starting database monitoring: $database_list"
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local database_issues=()
    
    # COMMENT: Parse database list
    local databases
    IFS=' ' read -ra databases <<< "$database_list"
    
    for database in "${databases[@]}"; do
        # COMMENT: Sanitize database name for security
        database=$(echo "$database" | sed 's/[^a-zA-Z0-9_-]/_/g')
        
        if [[ -z "$database" ]]; then
            continue
        fi
        
        log_info "Monitoring database: $database"
        
        # COMMENT: Check database status based on type
        case "$database" in
            postgresql|postgres)
                if command -v pg_isready >/dev/null 2>&1; then
                    if timeout "$monitoring_timeout" pg_isready -q 2>/dev/null; then
                        monitoring_results+=("PostgreSQL: OK")
                    else
                        database_issues+=("PostgreSQL: Connection failed")
                    fi
                elif systemctl is-active --quiet postgresql 2>/dev/null; then
                    monitoring_results+=("PostgreSQL: Service running")
                else
                    database_issues+=("PostgreSQL: Service not available")
                fi
                ;;
            mysql|mariadb)
                if command -v mysqladmin >/dev/null 2>&1; then
                    if timeout "$monitoring_timeout" mysqladmin ping -q 2>/dev/null; then
                        monitoring_results+=("MySQL: OK")
                    else
                        database_issues+=("MySQL: Connection failed")
                    fi
                elif systemctl is-active --quiet mysql 2>/dev/null || systemctl is-active --quiet mariadb 2>/dev/null; then
                    monitoring_results+=("MySQL: Service running")
                else
                    database_issues+=("MySQL: Service not available")
                fi
                ;;
            redis)
                if command -v redis-cli >/dev/null 2>&1; then
                    if timeout "$monitoring_timeout" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                        monitoring_results+=("Redis: OK")
                    else
                        database_issues+=("Redis: Connection failed")
                    fi
                elif systemctl is-active --quiet redis 2>/dev/null; then
                    monitoring_results+=("Redis: Service running")
                else
                    database_issues+=("Redis: Service not available")
                fi
                ;;
            *)
                log_warning "Unknown database type: $database"
                ;;
        esac
    done
    
    # COMMENT: Log monitoring results
    log_info "Database monitoring results:"
    for result in "${monitoring_results[@]}"; do
        log_info "  $result"
    done
    
    # COMMENT: Handle database issues
    if [[ ${#database_issues[@]} -gt 0 ]]; then
        log_error "Database issues detected:"
        for issue in "${database_issues[@]}"; do
            log_error "  $issue"
        done
        
        # COMMENT: Send database alert notification
        local alert_message="Database issues detected on $(hostname): $(printf '%s; ' "${database_issues[@]}")"
        send_notification "webhook" '{"url":"{{ vault_notification_webhook_url | default("") }}"} ' "$alert_message" || true
    fi
    
    # COMMENT: Return status based on database health
    if [[ ${#database_issues[@]} -gt 0 ]]; then
        return 2  # COMMENT: Critical status
    else
        log_success "Database monitoring completed - all databases healthy"
        return 0  # COMMENT: Normal status
    fi
}

# COMMENT: Production application monitoring with validation
monitor_applications() {
    local application_list="${1:-}"
    local monitoring_timeout="${2:-$MONITORING_TIMEOUT}"
    
    # COMMENT: Input validation for security
    if [[ -z "$application_list" ]]; then
        # COMMENT: Default applications to monitor
        application_list="nginx traefik grafana prometheus"
    fi
    
    log_info "Starting application monitoring: $application_list"
    
    # COMMENT: Initialize monitoring results
    local monitoring_results=()
    local application_issues=()
    
    # COMMENT: Parse application list
    local applications
    IFS=' ' read -ra applications <<< "$application_list"
    
    for application in "${applications[@]}"; do
        # COMMENT: Sanitize application name for security
        application=$(echo "$application" | sed 's/[^a-zA-Z0-9_-]/_/g')
        
        if [[ -z "$application" ]]; then
            continue
        fi
        
        log_info "Monitoring application: $application"
        
        # COMMENT: Check application status based on type
        case "$application" in
            nginx)
                if command -v nginx >/dev/null 2>&1; then
                    if nginx -t >/dev/null 2>&1; then
                        if systemctl is-active --quiet nginx 2>/dev/null; then
                            monitoring_results+=("Nginx: OK")
                        else
                            application_issues+=("Nginx: Service not running")
                        fi
                    else
                        application_issues+=("Nginx: Configuration error")
                    fi
                else
                    application_issues+=("Nginx: Not installed")
                fi
                ;;
            traefik)
                # COMMENT: Check Traefik container if running in Docker
                if command -v docker >/dev/null 2>&1; then
                    if docker ps --format "{{.Names}}" 2>/dev/null | grep -q "traefik"; then
                        monitoring_results+=("Traefik: Container running")
                    else
                        application_issues+=("Traefik: Container not running")
                    fi
                else
                    application_issues+=("Traefik: Docker not available")
                fi
                ;;
            grafana)
                # COMMENT: Check Grafana service
                if systemctl is-active --quiet grafana-server 2>/dev/null; then
                    monitoring_results+=("Grafana: Service running")
                elif command -v docker >/dev/null 2>&1 && docker ps --format "{{.Names}}" 2>/dev/null | grep -q "grafana"; then
                    monitoring_results+=("Grafana: Container running")
                else
                    application_issues+=("Grafana: Not running")
                fi
                ;;
            prometheus)
                # COMMENT: Check Prometheus service
                if systemctl is-active --quiet prometheus 2>/dev/null; then
                    monitoring_results+=("Prometheus: Service running")
                elif command -v docker >/dev/null 2>&1 && docker ps --format "{{.Names}}" 2>/dev/null | grep -q "prometheus"; then
                    monitoring_results+=("Prometheus: Container running")
                else
                    application_issues+=("Prometheus: Not running")
                fi
                ;;
            *)
                log_warning "Unknown application type: $application"
                ;;
        esac
    done
    
    # COMMENT: Log monitoring results
    log_info "Application monitoring results:"
    for result in "${monitoring_results[@]}"; do
        log_info "  $result"
    done
    
    # COMMENT: Handle application issues
    if [[ ${#application_issues[@]} -gt 0 ]]; then
        log_error "Application issues detected:"
        for issue in "${application_issues[@]}"; do
            log_error "  $issue"
        done
        
        # COMMENT: Send application alert notification
        local alert_message="Application issues detected on $(hostname): $(printf '%s; ' "${application_issues[@]}")"
        send_notification "webhook" '{"url":"{{ vault_notification_webhook_url | default("") }}"} ' "$alert_message" || true
    fi
    
    # COMMENT: Return status based on application health
    if [[ ${#application_issues[@]} -gt 0 ]]; then
        return 2  # COMMENT: Critical status
    else
        log_success "Application monitoring completed - all applications healthy"
        return 0  # COMMENT: Normal status
    fi
}

# COMMENT: Production comprehensive health check with validation
perform_health_check() {
    local health_check_type="${1:-all}"
    local monitoring_level="${2:-basic}"
    local output_file="${3:-}"
    
    # COMMENT: Input validation for security
    if ! validate_monitoring_type "$health_check_type"; then
        log_error "Invalid health check type: $health_check_type"
        return 1
    fi
    
    # COMMENT: Set output file if not specified
    if [[ -z "$output_file" ]]; then
        output_file="$SCRIPT_DIR/../logs/health_check_$(date +%Y%m%d_%H%M%S).log"
    fi
    
    # COMMENT: Create health check output directory
    local output_dir
    output_dir=$(dirname "$output_file")
    
    if [[ ! -d "$output_dir" ]]; then
        if ! mkdir -p "$output_dir" 2>/dev/null; then
            log_error "Failed to create health check output directory: $output_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on output directory
    if ! chmod 750 "$output_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on health check output directory"
    fi
    
    log_info "Starting comprehensive health check (type: $health_check_type, level: $monitoring_level)"
    log_info "Health check output: $output_file"
    
    # COMMENT: Initialize health check results
    local health_check_results=()
    local health_check_start_time
    health_check_start_time=$(date +%s)
    
    # COMMENT: Perform health checks based on type
    case "$health_check_type" in
        system)
            health_check_results+=("System resource monitoring")
            monitor_system_resources "$monitoring_level"
            ;;
        service)
            health_check_results+=("Service monitoring")
            monitor_services
            ;;
        network)
            health_check_results+=("Network monitoring")
            monitor_network "$monitoring_level"
            ;;
        database)
            health_check_results+=("Database monitoring")
            monitor_databases
            ;;
        application)
            health_check_results+=("Application monitoring")
            monitor_applications
            ;;
        all)
            health_check_results+=("Comprehensive health check")
            monitor_system_resources "$monitoring_level"
            monitor_services
            monitor_network "$monitoring_level"
            monitor_databases
            monitor_applications
            ;;
        *)
            log_error "Unsupported health check type: $health_check_type"
            return 1
            ;;
    esac
    
    # COMMENT: Calculate health check duration
    local health_check_end_time health_check_duration
    health_check_end_time=$(date +%s)
    health_check_duration=$((health_check_end_time - health_check_start_time))
    
    # COMMENT: Generate health check summary
    local health_check_summary="
=== HEALTH CHECK SUMMARY ===
Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
Environment: $MONITORING_UTILS_ENVIRONMENT
Health Check Type: $health_check_type
Monitoring Level: $monitoring_level
Duration: ${health_check_duration}s
Output File: $output_file

Health Checks Performed:
$(printf "  - %s\n" "${health_check_results[@]}")

Health check completed successfully.
"
    
    # COMMENT: Write health check results to output file
    if echo "$health_check_summary" > "$output_file" 2>/dev/null; then
        log_success "Health check completed successfully in ${health_check_duration}s"
        log_info "Health check results written to: $output_file"
        
        # COMMENT: Set secure permissions on output file
        if ! chmod 640 "$output_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on health check output file"
        fi
        
        return 0
    else
        log_error "Failed to write health check results to output file"
        return 1
    fi
}

# COMMENT: Production monitoring daemon setup with validation
setup_monitoring_daemon() {
    local daemon_config="${1:-}"
    local daemon_interval="${2:-$HEALTH_CHECK_INTERVAL}"
    
    log_info "Setting up monitoring daemon (interval: ${daemon_interval}s)"
    
    # COMMENT: Check if daemon is already running
    local daemon_pid_file
    daemon_pid_file="$SCRIPT_DIR/../logs/monitoring_daemon.pid"
    
    if [[ -f "$daemon_pid_file" ]]; then
        local daemon_pid
        daemon_pid=$(cat "$daemon_pid_file" 2>/dev/null)
        
        if [[ -n "$daemon_pid" ]] && kill -0 "$daemon_pid" 2>/dev/null; then
            log_warning "Monitoring daemon already running with PID: $daemon_pid"
            return 0
        else
            log_info "Removing stale PID file: $daemon_pid_file"
            rm -f "$daemon_pid_file" 2>/dev/null
        fi
    fi
    
    # COMMENT: Create daemon script
    local daemon_script
    daemon_script="$SCRIPT_DIR/../logs/monitoring_daemon.sh"
    
    cat > "$daemon_script" << 'EOF'
#!/bin/bash
# COMMENT: Monitoring daemon script
# COMMENT: Generated by monitoring_utils.sh

set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Source monitoring utilities
source "$SCRIPT_DIR/../scripts/monitoring_utils.sh"

# COMMENT: Daemon main loop
while true; do
    # COMMENT: Perform health check
    perform_health_check "all" "basic" "$SCRIPT_DIR/health_check_$(date +%Y%m%d_%H%M%S).log"
    
    # COMMENT: Wait for next interval
    sleep {{ health_check_interval | default(60) }}
done
EOF
    
    # COMMENT: Set secure permissions on daemon script
    if ! chmod 750 "$daemon_script" 2>/dev/null; then
        log_warning "Failed to set secure permissions on daemon script"
    fi
    
    # COMMENT: Start daemon in background
    nohup "$daemon_script" >/dev/null 2>&1 &
    local daemon_pid=$!
    
    # COMMENT: Save daemon PID
    echo "$daemon_pid" > "$daemon_pid_file" 2>/dev/null
    
    # COMMENT: Verify daemon is running
    sleep 2
    if kill -0 "$daemon_pid" 2>/dev/null; then
        log_success "Monitoring daemon started successfully with PID: $daemon_pid"
        return 0
    else
        log_error "Failed to start monitoring daemon"
        rm -f "$daemon_pid_file" 2>/dev/null
        return 1
    fi
}

# COMMENT: Production monitoring daemon control with validation
control_monitoring_daemon() {
    local action="$1"
    
    # COMMENT: Input validation for security
    case "$action" in
        start|stop|restart|status)
            ;;
        *)
            log_error "Invalid daemon action: $action"
            return 1
            ;;
    esac
    
    local daemon_pid_file
    daemon_pid_file="$SCRIPT_DIR/../logs/monitoring_daemon.pid"
    
    case "$action" in
        start)
            setup_monitoring_daemon
            ;;
        stop)
            if [[ -f "$daemon_pid_file" ]]; then
                local daemon_pid
                daemon_pid=$(cat "$daemon_pid_file" 2>/dev/null)
                
                if [[ -n "$daemon_pid" ]] && kill -0 "$daemon_pid" 2>/dev/null; then
                    if kill "$daemon_pid" 2>/dev/null; then
                        log_success "Monitoring daemon stopped successfully"
                        rm -f "$daemon_pid_file" 2>/dev/null
                        return 0
                    else
                        log_error "Failed to stop monitoring daemon"
                        return 1
                    fi
                else
                    log_warning "Monitoring daemon not running"
                    rm -f "$daemon_pid_file" 2>/dev/null
                    return 0
                fi
            else
                log_warning "Monitoring daemon PID file not found"
                return 0
            fi
            ;;
        restart)
            control_monitoring_daemon "stop"
            sleep 2
            control_monitoring_daemon "start"
            ;;
        status)
            if [[ -f "$daemon_pid_file" ]]; then
                local daemon_pid
                daemon_pid=$(cat "$daemon_pid_file" 2>/dev/null)
                
                if [[ -n "$daemon_pid" ]] && kill -0 "$daemon_pid" 2>/dev/null; then
                    log_info "Monitoring daemon is running with PID: $daemon_pid"
                    return 0
                else
                    log_info "Monitoring daemon is not running"
                    rm -f "$daemon_pid_file" 2>/dev/null
                    return 1
                fi
            else
                log_info "Monitoring daemon is not running"
                return 1
            fi
            ;;
    esac
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Monitoring Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive monitoring functions for production use.
    It includes system, service, network, database, and application monitoring.

FUNCTIONS:
    validate_monitoring_type <type> - Validate monitoring type
    monitor_system_resources [level] - Monitor system resources
    monitor_services [list] [timeout] - Monitor system services
    monitor_network [level] - Monitor network connectivity
    monitor_databases [list] [timeout] - Monitor database services
    monitor_applications [list] [timeout] - Monitor applications
    perform_health_check [type] [level] [output] - Perform comprehensive health check
    setup_monitoring_daemon [config] [interval] - Setup monitoring daemon
    control_monitoring_daemon <action> - Control monitoring daemon

MONITORING TYPES:
    system, service, network, database, application, custom

MONITORING LEVELS:
    basic, detailed, comprehensive

DAEMON ACTIONS:
    start, stop, restart, status

SECURITY FEATURES:
    - Input validation and sanitization
    - Secure monitoring execution
    - Alert notification integration
    - Comprehensive health checks
    - Daemon management

EXAMPLES:
    source $SCRIPT_NAME
    monitor_system_resources "detailed"
    perform_health_check "all" "comprehensive" "/var/log/health.log"
    setup_monitoring_daemon
    control_monitoring_daemon "status"

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize monitoring utilities if not already done
    if [[ -z "${MONITORING_UTILS_INITIALIZED:-}" ]]; then
        export MONITORING_UTILS_INITIALIZED="true"
        log_info "Monitoring utilities initialized successfully"
    fi
    
    # COMMENT: Log successful loading
    log_info "Monitoring utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
