#!/bin/bash
# COMMENT: Production-ready Backup Utilities for Ansible Homelab
# COMMENT: Comprehensive backup management with validation, encryption, and error handling
# COMMENT: Generated by: {{ ansible_managed }}
# COMMENT: Timestamp: {{ ansible_date_time.iso8601 }}
# COMMENT: Environment: {{ deployment_environment | default('production') }}

# COMMENT: Production security settings for backup utility reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="backup_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production backup configuration with validation
BACKUP_TYPES=("full" "incremental" "differential" "snapshot")
DEFAULT_BACKUP_TYPE="incremental"
BACKUP_TIMEOUT=3600
BACKUP_RETRIES=3
BACKUP_RETRY_DELAY=60
BACKUP_COMPRESSION_LEVEL=6
BACKUP_ENCRYPTION_ENABLED=true

# COMMENT: Production environment variables with validation
export BACKUP_UTILS_ENVIRONMENT="{{ deployment_environment | default('production') }}"
export BACKUP_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Source logging utilities if available
if [[ -f "$SCRIPT_DIR/logging_utils.sh" ]]; then
    source "$SCRIPT_DIR/logging_utils.sh"
else
    # COMMENT: Fallback logging if utilities not available
    log_info() { echo "[INFO] $1"; }
    log_warning() { echo "[WARNING] $1" >&2; }
    log_error() { echo "[ERROR] $1" >&2; }
    log_success() { echo "[SUCCESS] $1"; }
fi

# COMMENT: Production backup type validation with security
validate_backup_type() {
    local backup_type="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_type" ]]; then
        log_error "Backup type not specified"
        return 1
    fi
    
    # COMMENT: Validate backup type
    case "$backup_type" in
        full|incremental|differential|snapshot)
            return 0
            ;;
        *)
            log_error "Invalid backup type: $backup_type"
            return 1
            ;;
    esac
}

# COMMENT: Production backup path validation with security
validate_backup_path() {
    local backup_path="$1"
    local create_if_missing="${2:-false}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_path" ]]; then
        log_error "Backup path not specified"
        return 1
    fi
    
    # COMMENT: Check for path traversal attempts
    if echo "$backup_path" | grep -q -E "\.\.|//"; then
        log_error "Invalid backup path (path traversal detected): $backup_path"
        return 1
    fi
    
    # COMMENT: Check if path exists
    if [[ ! -e "$backup_path" ]]; then
        if [[ "$create_if_missing" == "true" ]]; then
            # COMMENT: Create backup directory
            if ! mkdir -p "$backup_path" 2>/dev/null; then
                log_error "Failed to create backup directory: $backup_path"
                return 1
            fi
            
            # COMMENT: Set secure permissions on backup directory
            if ! chmod 750 "$backup_path" 2>/dev/null; then
                log_warning "Failed to set secure permissions on backup directory"
            fi
            
            log_info "Created backup directory: $backup_path"
        else
            log_error "Backup path does not exist: $backup_path"
            return 1
        fi
    fi
    
    # COMMENT: Check if path is a directory
    if [[ ! -d "$backup_path" ]]; then
        log_error "Backup path is not a directory: $backup_path"
        return 1
    fi
    
    # COMMENT: Check if path is writable
    if [[ ! -w "$backup_path" ]]; then
        log_error "Backup path is not writable: $backup_path"
        return 1
    fi
    
    # COMMENT: Validate directory permissions
    local permissions
    permissions=$(stat -c "%a" "$backup_path" 2>/dev/null || stat -f "%Lp" "$backup_path" 2>/dev/null)
    
    if [[ -n "$permissions" ]]; then
        # COMMENT: Check if permissions are secure (750 or more restrictive)
        if [[ "$permissions" != "7"* ]] && [[ "$permissions" != "6"* ]] && [[ "$permissions" != "5"* ]]; then
            log_warning "Backup directory has insecure permissions: $backup_path ($permissions)"
        fi
    fi
    
    log_info "Backup path validation passed: $backup_path"
    return 0
}

# COMMENT: Production backup source validation with security
validate_backup_source() {
    local source_path="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$source_path" ]]; then
        log_error "Backup source path not specified"
        return 1
    fi
    
    # COMMENT: Check for path traversal attempts
    if echo "$source_path" | grep -q -E "\.\.|//"; then
        log_error "Invalid backup source path (path traversal detected): $source_path"
        return 1
    fi
    
    # COMMENT: Check if source exists
    if [[ ! -e "$source_path" ]]; then
        log_error "Backup source does not exist: $source_path"
        return 1
    fi
    
    # COMMENT: Check if source is readable
    if [[ ! -r "$source_path" ]]; then
        log_error "Backup source is not readable: $source_path"
        return 1
    fi
    
    # COMMENT: Get source information
    local source_type source_size
    if [[ -d "$source_path" ]]; then
        source_type="directory"
        source_size=$(du -sh "$source_path" 2>/dev/null | cut -f1 || echo "unknown")
    else
        source_type="file"
        source_size=$(stat -c "%s" "$source_path" 2>/dev/null | numfmt --to=iec || echo "unknown")
    fi
    
    log_info "Backup source validation passed: $source_path ($source_type, size: $source_size)"
    return 0
}

# COMMENT: Production backup encryption setup with security
setup_backup_encryption() {
    local encryption_key_file="$1"
    local backup_file="$2"
    
    # COMMENT: Input validation for security
    if [[ -z "$encryption_key_file" ]]; then
        log_error "Encryption key file not specified"
        return 1
    fi
    
    if [[ -z "$backup_file" ]]; then
        log_error "Backup file not specified for encryption"
        return 1
    fi
    
    # COMMENT: Check if encryption is enabled
    if [[ "$BACKUP_ENCRYPTION_ENABLED" != "true" ]]; then
        log_info "Backup encryption is disabled"
        return 0
    fi
    
    # COMMENT: Check if encryption key file exists
    if [[ ! -f "$encryption_key_file" ]]; then
        log_error "Encryption key file not found: $encryption_key_file"
        return 1
    fi
    
    # COMMENT: Validate encryption key file permissions
    local key_permissions
    key_permissions=$(stat -c "%a" "$encryption_key_file" 2>/dev/null || stat -f "%Lp" "$encryption_key_file" 2>/dev/null)
    
    if [[ -n "$key_permissions" && "$key_permissions" != "600" ]]; then
        log_warning "Encryption key file has insecure permissions: $key_permissions (should be 600)"
    fi
    
    # COMMENT: Check if gpg is available
    if ! command -v gpg >/dev/null 2>&1; then
        log_error "gpg command not available for encryption"
        return 1
    fi
    
    log_info "Setting up backup encryption with key: $encryption_key_file"
    return 0
}

# COMMENT: Production backup compression with validation
compress_backup_file() {
    local source_file="$1"
    local compressed_file="$2"
    local compression_level="${3:-$BACKUP_COMPRESSION_LEVEL}"
    
    # COMMENT: Input validation for security
    if [[ -z "$source_file" ]]; then
        log_error "Source file not specified for compression"
        return 1
    fi
    
    if [[ -z "$compressed_file" ]]; then
        log_error "Compressed file path not specified"
        return 1
    fi
    
    if [[ ! -f "$source_file" ]]; then
        log_error "Source file does not exist: $source_file"
        return 1
    fi
    
    # COMMENT: Validate compression level
    if ! echo "$compression_level" | grep -E '^[1-9]$' >/dev/null; then
        log_warning "Invalid compression level: $compression_level, using default: $BACKUP_COMPRESSION_LEVEL"
        compression_level="$BACKUP_COMPRESSION_LEVEL"
    fi
    
    # COMMENT: Check if gzip is available
    if ! command -v gzip >/dev/null 2>&1; then
        log_error "gzip command not available for compression"
        return 1
    fi
    
    # COMMENT: Compress backup file
    log_info "Compressing backup file: $source_file -> $compressed_file (level: $compression_level)"
    
    if gzip -"$compression_level" -c "$source_file" > "$compressed_file" 2>/dev/null; then
        # COMMENT: Set secure permissions on compressed file
        if ! chmod 640 "$compressed_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on compressed file"
        fi
        
        # COMMENT: Verify compression
        local original_size compressed_size
        original_size=$(stat -c "%s" "$source_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        compressed_size=$(stat -c "%s" "$compressed_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        
        log_success "Backup compression completed: $source_file -> $compressed_file"
        log_info "Compression results: $original_size -> $compressed_size"
        
        return 0
    else
        log_error "Backup compression failed: $source_file"
        return 1
    fi
}

# COMMENT: Production backup encryption with validation
encrypt_backup_file() {
    local source_file="$1"
    local encrypted_file="$2"
    local encryption_key_file="$3"
    
    # COMMENT: Input validation for security
    if [[ -z "$source_file" ]]; then
        log_error "Source file not specified for encryption"
        return 1
    fi
    
    if [[ -z "$encrypted_file" ]]; then
        log_error "Encrypted file path not specified"
        return 1
    fi
    
    if [[ -z "$encryption_key_file" ]]; then
        log_error "Encryption key file not specified"
        return 1
    fi
    
    if [[ ! -f "$source_file" ]]; then
        log_error "Source file does not exist: $source_file"
        return 1
    fi
    
    if [[ ! -f "$encryption_key_file" ]]; then
        log_error "Encryption key file not found: $encryption_key_file"
        return 1
    fi
    
    # COMMENT: Check if encryption is enabled
    if [[ "$BACKUP_ENCRYPTION_ENABLED" != "true" ]]; then
        log_info "Backup encryption is disabled, copying file without encryption"
        if cp "$source_file" "$encrypted_file" 2>/dev/null; then
            # COMMENT: Set secure permissions on copied file
            if ! chmod 640 "$encrypted_file" 2>/dev/null; then
                log_warning "Failed to set secure permissions on copied file"
            fi
            return 0
        else
            log_error "Failed to copy file without encryption"
            return 1
        fi
    fi
    
    # COMMENT: Check if gpg is available
    if ! command -v gpg >/dev/null 2>&1; then
        log_error "gpg command not available for encryption"
        return 1
    fi
    
    # COMMENT: Encrypt backup file
    log_info "Encrypting backup file: $source_file -> $encrypted_file"
    
    if gpg --batch --yes --recipient-file "$encryption_key_file" --output "$encrypted_file" --encrypt "$source_file" 2>/dev/null; then
        # COMMENT: Set secure permissions on encrypted file
        if ! chmod 640 "$encrypted_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on encrypted file"
        fi
        
        # COMMENT: Verify encryption
        local original_size encrypted_size
        original_size=$(stat -c "%s" "$source_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        encrypted_size=$(stat -c "%s" "$encrypted_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        
        log_success "Backup encryption completed: $source_file -> $encrypted_file"
        log_info "Encryption results: $original_size -> $encrypted_size"
        
        return 0
    else
        log_error "Backup encryption failed: $source_file"
        return 1
    fi
}

# COMMENT: Production backup integrity check with validation
verify_backup_integrity() {
    local backup_file="$1"
    local backup_type="${2:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_file" ]]; then
        log_error "Backup file not specified for integrity check"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        log_error "Backup file does not exist: $backup_file"
        return 1
    fi
    
    log_info "Verifying backup integrity: $backup_file (type: $backup_type)"
    
    # COMMENT: Check file size
    local file_size
    file_size=$(stat -c "%s" "$backup_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
    
    if [[ "$file_size" == "0" ]]; then
        log_error "Backup file is empty: $backup_file"
        return 1
    fi
    
    log_info "Backup file size: $file_size"
    
    # COMMENT: Check file format based on type
    case "$backup_type" in
        tar|tar.gz|tgz)
            # COMMENT: Verify tar archive integrity
            if ! tar -tf "$backup_file" >/dev/null 2>&1; then
                log_error "Backup file is not a valid tar archive: $backup_file"
                return 1
            fi
            log_info "Tar archive integrity verified"
            ;;
        gz)
            # COMMENT: Verify gzip integrity
            if ! gzip -t "$backup_file" 2>/dev/null; then
                log_error "Backup file is not a valid gzip file: $backup_file"
                return 1
            fi
            log_info "Gzip integrity verified"
            ;;
        gpg)
            # COMMENT: Verify GPG encryption
            if ! gpg --batch --yes --list-only "$backup_file" >/dev/null 2>&1; then
                log_error "Backup file is not a valid GPG encrypted file: $backup_file"
                return 1
            fi
            log_info "GPG encryption verified"
            ;;
        *)
            log_warning "Unknown backup type, skipping format validation: $backup_type"
            ;;
    esac
    
    # COMMENT: Calculate checksum for integrity
    local checksum
    if command -v sha256sum >/dev/null 2>&1; then
        checksum=$(sha256sum "$backup_file" 2>/dev/null | cut -d' ' -f1)
        log_info "Backup file SHA256 checksum: $checksum"
    elif command -v shasum >/dev/null 2>&1; then
        checksum=$(shasum -a 256 "$backup_file" 2>/dev/null | cut -d' ' -f1)
        log_info "Backup file SHA256 checksum: $checksum"
    else
        log_warning "Checksum calculation not available"
    fi
    
    log_success "Backup integrity verification passed: $backup_file"
    return 0
}

# COMMENT: Production backup creation with comprehensive validation
create_backup() {
    local source_path="$1"
    local backup_dir="$2"
    local backup_type="${3:-$DEFAULT_BACKUP_TYPE}"
    local backup_name="${4:-}"
    local encrypt_backup="${5:-$BACKUP_ENCRYPTION_ENABLED}"
    
    # COMMENT: Input validation for security
    if [[ -z "$source_path" ]]; then
        log_error "Backup source path not specified"
        return 1
    fi
    
    if [[ -z "$backup_dir" ]]; then
        log_error "Backup directory not specified"
        return 1
    fi
    
    # COMMENT: Validate backup type
    if ! validate_backup_type "$backup_type"; then
        return 1
    fi
    
    # COMMENT: Validate backup source
    if ! validate_backup_source "$source_path"; then
        return 1
    fi
    
    # COMMENT: Validate backup directory
    if ! validate_backup_path "$backup_dir" "true"; then
        return 1
    fi
    
    # COMMENT: Generate backup name if not provided
    if [[ -z "$backup_name" ]]; then
        local source_basename timestamp
        source_basename=$(basename "$source_path")
        timestamp=$(date +%Y%m%d_%H%M%S)
        backup_name="${source_basename}_${backup_type}_${timestamp}"
    fi
    
    # COMMENT: Create backup file paths
    local backup_file_base backup_file_compressed backup_file_encrypted
    backup_file_base="$backup_dir/${backup_name}.tar"
    backup_file_compressed="$backup_dir/${backup_name}.tar.gz"
    backup_file_encrypted="$backup_dir/${backup_name}.tar.gz.gpg"
    
    log_info "Starting backup creation: $source_path -> $backup_dir"
    log_info "Backup type: $backup_type, Name: $backup_name"
    
    # COMMENT: Create tar archive
    log_info "Creating tar archive: $source_path -> $backup_file_base"
    
    if tar -cf "$backup_file_base" -C "$(dirname "$source_path")" "$(basename "$source_path")" 2>/dev/null; then
        # COMMENT: Set secure permissions on tar file
        if ! chmod 640 "$backup_file_base" 2>/dev/null; then
            log_warning "Failed to set secure permissions on tar file"
        fi
        
        log_success "Tar archive created: $backup_file_base"
    else
        log_error "Failed to create tar archive: $source_path"
        return 1
    fi
    
    # COMMENT: Compress backup file
    if ! compress_backup_file "$backup_file_base" "$backup_file_compressed"; then
        log_error "Backup compression failed"
        return 1
    fi
    
    # COMMENT: Remove uncompressed tar file
    if ! rm -f "$backup_file_base" 2>/dev/null; then
        log_warning "Failed to remove uncompressed tar file: $backup_file_base"
    fi
    
    # COMMENT: Encrypt backup file if requested
    if [[ "$encrypt_backup" == "true" ]]; then
        local encryption_key_file
        encryption_key_file="$SCRIPT_DIR/../config/backup_encryption_key.gpg"
        
        if ! encrypt_backup_file "$backup_file_compressed" "$backup_file_encrypted" "$encryption_key_file"; then
            log_error "Backup encryption failed"
            return 1
        fi
        
        # COMMENT: Remove unencrypted compressed file
        if ! rm -f "$backup_file_compressed" 2>/dev/null; then
            log_warning "Failed to remove unencrypted compressed file: $backup_file_compressed"
        fi
        
        # COMMENT: Set final backup file
        local final_backup_file="$backup_file_encrypted"
    else
        # COMMENT: Set final backup file
        local final_backup_file="$backup_file_compressed"
    fi
    
    # COMMENT: Verify backup integrity
    if ! verify_backup_integrity "$final_backup_file" "$backup_type"; then
        log_error "Backup integrity verification failed"
        return 1
    fi
    
    # COMMENT: Create backup metadata
    local backup_metadata_file
    backup_metadata_file="$backup_dir/${backup_name}.metadata.json"
    
    local metadata="{
        \"backup_name\": \"$backup_name\",
        \"backup_type\": \"$backup_type\",
        \"source_path\": \"$source_path\",
        \"backup_file\": \"$final_backup_file\",
        \"created_at\": \"$(date -u '+%Y-%m-%d %H:%M:%S UTC')\",
        \"environment\": \"$BACKUP_UTILS_ENVIRONMENT\",
        \"encrypted\": $encrypt_backup,
        \"compressed\": true,
        \"integrity_verified\": true
    }"
    
    if echo "$metadata" > "$backup_metadata_file" 2>/dev/null; then
        # COMMENT: Set secure permissions on metadata file
        if ! chmod 640 "$backup_metadata_file" 2>/dev/null; then
            log_warning "Failed to set secure permissions on metadata file"
        fi
        
        log_info "Backup metadata created: $backup_metadata_file"
    else
        log_warning "Failed to create backup metadata file"
    fi
    
    # COMMENT: Get final backup size
    local final_size
    final_size=$(stat -c "%s" "$final_backup_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
    
    log_success "Backup creation completed successfully"
    log_info "Final backup file: $final_backup_file (size: $final_size)"
    
    return 0
}

# COMMENT: Production backup restoration with validation
restore_backup() {
    local backup_file="$1"
    local restore_path="$2"
    local encryption_key_file="${3:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_file" ]]; then
        log_error "Backup file not specified for restoration"
        return 1
    fi
    
    if [[ -z "$restore_path" ]]; then
        log_error "Restore path not specified"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        log_error "Backup file does not exist: $backup_file"
        return 1
    fi
    
    # COMMENT: Check for path traversal attempts
    if echo "$restore_path" | grep -q -E "\.\.|//"; then
        log_error "Invalid restore path (path traversal detected): $restore_path"
        return 1
    fi
    
    log_info "Starting backup restoration: $backup_file -> $restore_path"
    
    # COMMENT: Verify backup integrity before restoration
    if ! verify_backup_integrity "$backup_file"; then
        log_error "Backup integrity verification failed, cannot restore"
        return 1
    fi
    
    # COMMENT: Create restore directory if it doesn't exist
    if [[ ! -d "$restore_path" ]]; then
        if ! mkdir -p "$restore_path" 2>/dev/null; then
            log_error "Failed to create restore directory: $restore_path"
            return 1
        fi
        
        # COMMENT: Set secure permissions on restore directory
        if ! chmod 750 "$restore_path" 2>/dev/null; then
            log_warning "Failed to set secure permissions on restore directory"
        fi
    fi
    
    # COMMENT: Determine backup file type and handle accordingly
    local file_extension
    file_extension="${backup_file##*.}"
    
    case "$file_extension" in
        gpg)
            # COMMENT: Decrypt backup file
            if [[ -z "$encryption_key_file" ]]; then
                encryption_key_file="$SCRIPT_DIR/../config/backup_encryption_key.gpg"
            fi
            
            if [[ ! -f "$encryption_key_file" ]]; then
                log_error "Encryption key file not found: $encryption_key_file"
                return 1
            fi
            
            local decrypted_file
            decrypted_file="${backup_file%.gpg}"
            
            log_info "Decrypting backup file: $backup_file -> $decrypted_file"
            
            if ! gpg --batch --yes --recipient-file "$encryption_key_file" --output "$decrypted_file" --decrypt "$backup_file" 2>/dev/null; then
                log_error "Backup decryption failed"
                return 1
            fi
            
            # COMMENT: Set secure permissions on decrypted file
            if ! chmod 640 "$decrypted_file" 2>/dev/null; then
                log_warning "Failed to set secure permissions on decrypted file"
            fi
            
            # COMMENT: Continue with decrypted file
            backup_file="$decrypted_file"
            ;;
    esac
    
    # COMMENT: Extract backup based on file type
    if [[ "$backup_file" == *.tar.gz ]] || [[ "$backup_file" == *.tgz ]]; then
        # COMMENT: Extract compressed tar archive
        log_info "Extracting compressed tar archive: $backup_file -> $restore_path"
        
        if ! tar -xzf "$backup_file" -C "$restore_path" 2>/dev/null; then
            log_error "Failed to extract compressed tar archive"
            return 1
        fi
    elif [[ "$backup_file" == *.tar ]]; then
        # COMMENT: Extract tar archive
        log_info "Extracting tar archive: $backup_file -> $restore_path"
        
        if ! tar -xf "$backup_file" -C "$restore_path" 2>/dev/null; then
            log_error "Failed to extract tar archive"
            return 1
        fi
    else
        log_error "Unsupported backup file format: $backup_file"
        return 1
    fi
    
    # COMMENT: Clean up temporary decrypted file
    if [[ -n "${decrypted_file:-}" && -f "$decrypted_file" ]]; then
        if ! rm -f "$decrypted_file" 2>/dev/null; then
            log_warning "Failed to remove temporary decrypted file: $decrypted_file"
        fi
    fi
    
    # COMMENT: Set secure permissions on restored files
    if ! chmod -R 640 "$restore_path" 2>/dev/null; then
        log_warning "Failed to set secure permissions on restored files"
    fi
    
    if ! chmod 750 "$restore_path" 2>/dev/null; then
        log_warning "Failed to set secure permissions on restore directory"
    fi
    
    log_success "Backup restoration completed successfully: $backup_file -> $restore_path"
    return 0
}

# COMMENT: Production backup cleanup with validation
cleanup_old_backups() {
    local backup_dir="$1"
    local max_age_days="${2:-30}"
    local dry_run="${3:-false}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_dir" ]]; then
        log_error "Backup directory not specified for cleanup"
        return 1
    fi
    
    if [[ ! -d "$backup_dir" ]]; then
        log_error "Backup directory does not exist: $backup_dir"
        return 1
    fi
    
    # COMMENT: Validate max age
    if ! echo "$max_age_days" | grep -E '^[0-9]+$' >/dev/null || [[ "$max_age_days" -lt 1 ]]; then
        log_error "Invalid max age for cleanup: $max_age_days"
        return 1
    fi
    
    log_info "Starting backup cleanup: $backup_dir (max age: ${max_age_days} days, dry_run: $dry_run)"
    
    # COMMENT: Find old backup files
    local old_backups
    old_backups=$(find "$backup_dir" -name "*.tar.gz*" -type f -mtime +"$max_age_days" 2>/dev/null || true)
    
    if [[ -z "$old_backups" ]]; then
        log_info "No old backup files found for cleanup"
        return 0
    fi
    
    local backup_count
    backup_count=$(echo "$old_backups" | wc -l)
    
    log_info "Found $backup_count old backup files for cleanup:"
    echo "$old_backups" | while read -r backup_file; do
        local file_size file_age
        file_size=$(stat -c "%s" "$backup_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        file_age=$(stat -c "%Y" "$backup_file" 2>/dev/null | xargs -I {} date -d @{} +%Y-%m-%d 2>/dev/null || echo "unknown")
        log_info "  $backup_file (size: $file_size, age: $file_age)"
    done
    
    if [[ "$dry_run" == "true" ]]; then
        log_info "Dry run mode - no files will be deleted"
        return 0
    fi
    
    # COMMENT: Remove old backup files
    local removed_count=0
    local failed_count=0
    
    echo "$old_backups" | while read -r backup_file; do
        if rm -f "$backup_file" 2>/dev/null; then
            log_info "Removed old backup file: $backup_file"
    local removed_count=0
    local failed_count=0
    local temp_file
    temp_file=$(mktemp)

    while read -r backup_file; do
        if rm -f "$backup_file" 2>/dev/null; then
            log_info "Removed old backup file: $backup_file"
            echo "removed" >> "$temp_file"
        else
            log_error "Failed to remove old backup file: $backup_file"
            echo "failed" >> "$temp_file"
        fi
    done <<< "$old_backups"

    removed_count=$(grep -c "removed" "$temp_file" 2>/dev/null || echo 0)
    failed_count=$(grep -c "failed" "$temp_file" 2>/dev/null || echo 0)
    rm -f "$temp_file"
    done
    
    # COMMENT: Clean up orphaned metadata files
    local orphaned_metadata
    orphaned_metadata=$(find "$backup_dir" -name "*.metadata.json" -type f 2>/dev/null | while read -r metadata_file; do
        local backup_name
        backup_name=$(basename "$metadata_file" .metadata.json)
        local backup_files
        backup_files=$(find "$backup_dir" -name "${backup_name}.*" -type f ! -name "*.metadata.json" 2>/dev/null)
        if [[ -z "$backup_files" ]]; then
            echo "$metadata_file"
        fi
    done)
    
    if [[ -n "$orphaned_metadata" ]]; then
        local orphaned_count
        orphaned_count=$(echo "$orphaned_metadata" | wc -l)
        log_info "Found $orphaned_count orphaned metadata files for cleanup"
        
        echo "$orphaned_metadata" | while read -r metadata_file; do
            if rm -f "$metadata_file" 2>/dev/null; then
                log_info "Removed orphaned metadata file: $metadata_file"
            else
                log_warning "Failed to remove orphaned metadata file: $metadata_file"
            fi
        done
    fi
    
    log_success "Backup cleanup completed: $removed_count files removed, $failed_count failures"
    return 0
}

# COMMENT: Production backup listing with validation
list_backups() {
    local backup_dir="$1"
    local show_details="${2:-false}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_dir" ]]; then
        log_error "Backup directory not specified for listing"
        return 1
    fi
    
    if [[ ! -d "$backup_dir" ]]; then
        log_error "Backup directory does not exist: $backup_dir"
        return 1
    fi
    
    log_info "Listing backups in directory: $backup_dir"
    
    # COMMENT: Find backup files
    local backup_files
    backup_files=$(find "$backup_dir" -name "*.tar.gz*" -type f 2>/dev/null | sort || true)
    
    if [[ -z "$backup_files" ]]; then
        log_info "No backup files found in directory: $backup_dir"
        return 0
    fi
    
    local backup_count
    backup_count=$(echo "$backup_files" | wc -l)
    
    log_info "Found $backup_count backup files:"
    
    echo "$backup_files" | while read -r backup_file; do
        local file_size file_age file_permissions
        file_size=$(stat -c "%s" "$backup_file" 2>/dev/null | numfmt --to=iec || echo "unknown")
        file_age=$(stat -c "%Y" "$backup_file" 2>/dev/null | xargs -I {} date -d @{} +%Y-%m-%d 2>/dev/null || echo "unknown")
        file_permissions=$(stat -c "%a" "$backup_file" 2>/dev/null || echo "unknown")
        
        if [[ "$show_details" == "true" ]]; then
            log_info "  $backup_file"
            log_info "    Size: $file_size, Age: $file_age, Permissions: $file_permissions"
        else
            log_info "  $backup_file (size: $file_size, age: $file_age)"
        fi
    done
    
    return 0
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Backup Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive backup functions for production use.
    It includes creation, restoration, validation, encryption, and cleanup.

FUNCTIONS:
    validate_backup_type <type> - Validate backup type
    validate_backup_path <path> [create] - Validate backup path
    validate_backup_source <path> - Validate backup source
    setup_backup_encryption <key_file> <backup_file> - Setup backup encryption
    compress_backup_file <source> <compressed> [level] - Compress backup file
    encrypt_backup_file <source> <encrypted> <key_file> - Encrypt backup file
    verify_backup_integrity <file> [type] - Verify backup integrity
    create_backup <source> <dir> [type] [name] [encrypt] - Create backup
    restore_backup <file> <path> [key_file] - Restore backup
    cleanup_old_backups <dir> [max_age] [dry_run] - Cleanup old backups
    list_backups <dir> [details] - List backup files

BACKUP TYPES:
    full, incremental, differential, snapshot

SECURITY FEATURES:
    - Input validation and sanitization
    - Path traversal protection
    - File permission validation
    - Backup encryption with GPG
    - Integrity verification
    - Secure file handling

EXAMPLES:
    source $SCRIPT_NAME
    create_backup "/var/app" "/backups" "incremental" "app_backup" "true"
    restore_backup "/backups/app_backup.tar.gz.gpg" "/var/app_restored"
    cleanup_old_backups "/backups" 30 "false"
    list_backups "/backups" "true"

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize backup utilities if not already done
    if [[ -z "${BACKUP_UTILS_INITIALIZED:-}" ]]; then
        export BACKUP_UTILS_INITIALIZED="true"
        log_info "Backup utilities initialized successfully"
    fi
    
    # COMMENT: Log successful loading
    log_info "Backup utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
