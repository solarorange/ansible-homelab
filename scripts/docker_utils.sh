#!/bin/bash
# COMMENT: Production-ready Docker Utilities for Ansible Homelab
# COMMENT: Comprehensive Docker management, security validation, and container operations
# COMMENT: Generated by: Ansible automation
# COMMENT: Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
# COMMENT: Environment: production

# COMMENT: Production security settings for Docker utility reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="docker_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production Docker configuration with validation
DOCKER_OPERATIONS=("start" "stop" "restart" "status" "logs" "inspect" "exec" "backup" "restore" "cleanup")
DEFAULT_DOCKER_OPERATION="status"
DOCKER_TIMEOUT=300
DOCKER_RETRIES=3
DOCKER_RETRY_DELAY=10
DOCKER_BACKUP_RETENTION_DAYS=30

# COMMENT: Production environment variables with validation
export DOCKER_UTILS_ENVIRONMENT="production"
export DOCKER_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Source logging utilities if available
if [[ -f "$SCRIPT_DIR/logging_utils.sh" ]]; then
    source "$SCRIPT_DIR/logging_utils.sh"
else
    # COMMENT: Fallback logging if utilities not available
    log_info() { echo "[INFO] $1"; }
    log_warning() { echo "[WARNING] $1" >&2; }
    log_error() { echo "[ERROR] $1" >&2; }
    log_success() { echo "[SUCCESS] $1"; }
fi

# COMMENT: Source security utilities if available
if [[ -f "$SCRIPT_DIR/security_utils.sh" ]]; then
    source "$SCRIPT_DIR/security_utils.sh"
else
    # COMMENT: Fallback security if utilities not available
    validate_docker_security() { log_warning "Security utilities not available"; return 0; }
fi

# COMMENT: Production Docker availability check with validation
check_docker_availability() {
    log_info "Checking Docker availability"
    
    # COMMENT: Check if Docker command is available
    if ! command -v docker >/dev/null 2>&1; then
        log_error "Docker command not available"
        return 1
    fi
    
    # COMMENT: Check if Docker daemon is running
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon is not running or not accessible"
        return 1
    fi
    
    # COMMENT: Get Docker version and info
    local docker_version docker_info
    docker_version=$(docker --version 2>/dev/null || echo "unknown")
    docker_info=$(docker info 2>/dev/null | grep -E "(Server Version|Operating System|Kernel Version)" | head -3 || true)
    
    log_info "Docker version: $docker_version"
    if [[ -n "$docker_info" ]]; then
        log_info "Docker system info:"
        echo "$docker_info" | while read -r line; do
            log_info "  $line"
        done
    fi
    
    log_success "Docker availability check passed"
    return 0
}

# COMMENT: Production Docker operation validation with security
validate_docker_operation() {
    local operation="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$operation" ]]; then
        log_error "Docker operation not specified"
        return 1
    fi
    
    # COMMENT: Validate Docker operation
    case "$operation" in
        start|stop|restart|status|logs|inspect|exec|backup|restore|cleanup)
            return 0
            ;;
        *)
            log_error "Invalid Docker operation: $operation"
            return 1
            ;;
    esac
}

# COMMENT: Production Docker container validation with security
validate_docker_container() {
    local container_name="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$container_name" ]]; then
        log_error "Container name not specified"
        return 1
    fi
    
    # COMMENT: Sanitize container name for security
    container_name=$(echo "$container_name" | sed 's/[^a-zA-Z0-9._-]/_/g')
    
    if [[ -z "$container_name" ]]; then
        log_error "Invalid container name after sanitization"
        return 1
    fi
    
    # COMMENT: Check if container exists
    if ! docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
        log_error "Container does not exist: $container_name"
        return 1
    fi
    
    log_info "Container validation passed: $container_name"
    return 0
}

# COMMENT: Production Docker container status check with validation
check_container_status() {
    local container_name="$1"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    log_info "Checking container status: $container_name"
    
    # COMMENT: Get container status
    local container_status
    container_status=$(docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" --filter "name=^${container_name}$" 2>/dev/null || true)
    
    if [[ -n "$container_status" ]]; then
        log_info "Container status:"
        echo "$container_status" | while read -r line; do
            log_info "  $line"
        done
        return 0
    else
        log_warning "Container is not running: $container_name"
        return 1
    fi
}

# COMMENT: Production Docker container start with validation
start_container() {
    local container_name="$1"
    local timeout="${2:-$DOCKER_TIMEOUT}"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    log_info "Starting container: $container_name (timeout: ${timeout}s)"
    
    # COMMENT: Check if container is already running
    if check_container_status "$container_name" >/dev/null 2>&1; then
        log_info "Container is already running: $container_name"
        return 0
    fi
    
    # COMMENT: Start container
    if docker start "$container_name" >/dev/null 2>&1; then
        log_success "Container started successfully: $container_name"
        
        # COMMENT: Wait for container to be ready
        log_info "Waiting for container to be ready: $container_name"
        local wait_time=0
        while [[ $wait_time -lt $timeout ]]; do
            if check_container_status "$container_name" >/dev/null 2>&1; then
                log_success "Container is ready: $container_name"
                return 0
            fi
            sleep 5
            wait_time=$((wait_time + 5))
        done
        
        log_warning "Container start timeout reached: $container_name"
        return 1
    else
        log_error "Failed to start container: $container_name"
        return 1
    fi
}

# COMMENT: Production Docker container stop with validation
stop_container() {
    local container_name="$1"
    local force="${2:-false}"
    local timeout="${3:-$DOCKER_TIMEOUT}"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    log_info "Stopping container: $container_name (force: $force, timeout: ${timeout}s)"
    
    # COMMENT: Check if container is running
    if ! check_container_status "$container_name" >/dev/null 2>&1; then
        log_info "Container is not running: $container_name"
        return 0
    fi
    
    # COMMENT: Stop container
    local stop_cmd="docker stop"
    if [[ "$force" == "true" ]]; then
        stop_cmd="docker kill"
    fi
    
    if $stop_cmd "$container_name" >/dev/null 2>&1; then
        log_success "Container stopped successfully: $container_name"
        
        # COMMENT: Wait for container to stop
        log_info "Waiting for container to stop: $container_name"
        local wait_time=0
        while [[ $wait_time -lt $timeout ]]; do
            if ! check_container_status "$container_name" >/dev/null 2>&1; then
                log_success "Container has stopped: $container_name"
                return 0
            fi
            sleep 5
            wait_time=$((wait_time + 5))
        done
        
        log_warning "Container stop timeout reached: $container_name"
        return 1
    else
        log_error "Failed to stop container: $container_name"
        return 1
    fi
}

# COMMENT: Production Docker container restart with validation
restart_container() {
    local container_name="$1"
    local timeout="${2:-$DOCKER_TIMEOUT}"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    log_info "Restarting container: $container_name (timeout: ${timeout}s)"
    
    # COMMENT: Stop container
    if ! stop_container "$container_name" "false" "$timeout"; then
        log_error "Failed to stop container for restart: $container_name"
        return 1
    fi
    
    # COMMENT: Start container
    if ! start_container "$container_name" "$timeout"; then
        log_error "Failed to start container after restart: $container_name"
        return 1
    fi
    
    log_success "Container restarted successfully: $container_name"
    return 0
}

# COMMENT: Production Docker container logs with validation
get_container_logs() {
    local container_name="$1"
    local log_lines="${2:-100}"
    local output_file="${3:-}"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    # COMMENT: Validate log lines
    if ! echo "$log_lines" | grep -E '^[0-9]+$' >/dev/null || [[ "$log_lines" -lt 1 || "$log_lines" -gt 10000 ]]; then
        log_warning "Invalid log lines count: $log_lines, using default: 100"
        log_lines=100
    fi
    
    log_info "Getting container logs: $container_name (lines: $log_lines)"
    
    # COMMENT: Get container logs
    local container_logs
    if container_logs=$(docker logs --tail "$log_lines" "$container_name" 2>/dev/null); then
        if [[ -n "$output_file" ]]; then
            # COMMENT: Write logs to output file
            local output_dir
            output_dir=$(dirname "$output_file")
            
            if [[ ! -d "$output_dir" ]]; then
                if ! mkdir -p "$output_dir" 2>/dev/null; then
                    log_error "Failed to create output directory: $output_dir"
                    return 1
                fi
            fi
            
            if echo "$container_logs" > "$output_file" 2>/dev/null; then
                # COMMENT: Set secure permissions on output file
                if ! chmod 640 "$output_file" 2>/dev/null; then
                    log_warning "Failed to set secure permissions on output file"
                fi
                
                log_success "Container logs written to: $output_file"
                return 0
            else
                log_error "Failed to write container logs to output file"
                return 1
            fi
        else
            # COMMENT: Display logs to console
            log_info "Container logs for $container_name:"
            echo "$container_logs"
            return 0
        fi
    else
        log_error "Failed to get container logs: $container_name"
        return 1
    fi
}

# COMMENT: Production Docker container inspection with validation
inspect_container() {
    local container_name="$1"
    local output_file="${2:-}"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    log_info "Inspecting container: $container_name"
    
    # COMMENT: Inspect container
    local container_info
    if container_info=$(docker inspect "$container_name" 2>/dev/null); then
        if [[ -n "$output_file" ]]; then
            # COMMENT: Write inspection to output file
            local output_dir
            output_dir=$(dirname "$output_file")
            
            if [[ ! -d "$output_dir" ]]; then
                if ! mkdir -p "$output_dir" 2>/dev/null; then
                    log_error "Failed to create output directory: $output_dir"
                    return 1
                fi
            fi
            
            if echo "$container_info" > "$output_file" 2>/dev/null; then
                # COMMENT: Set secure permissions on output file
                if ! chmod 640 "$output_file" 2>/dev/null; then
                    log_warning "Failed to set secure permissions on output file"
                fi
                
                log_success "Container inspection written to: $output_file"
                return 0
            else
                log_error "Failed to write container inspection to output file"
                return 1
            fi
        else
            # COMMENT: Display inspection to console
            log_info "Container inspection for $container_name:"
            echo "$container_info" | python3 -m json.tool 2>/dev/null || echo "$container_info"
            return 0
        fi
    else
        log_error "Failed to inspect container: $container_name"
        return 1
    fi
}

# COMMENT: Production Docker container backup with validation
backup_container() {
    local container_name="$1"
    local backup_dir="$2"
    local backup_name="${3:-}"
    
    # COMMENT: Input validation for security
    if ! validate_docker_container "$container_name"; then
        return 1
    fi
    
    if [[ -z "$backup_dir" ]]; then
        backup_dir="$SCRIPT_DIR/../backups/docker"
    fi
    
    # COMMENT: Validate backup directory
    if [[ ! -d "$backup_dir" ]]; then
        if ! mkdir -p "$backup_dir" 2>/dev/null; then
            log_error "Failed to create backup directory: $backup_dir"
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on backup directory
    if ! chmod 750 "$backup_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on backup directory"
    fi
    
    # COMMENT: Generate backup name if not provided
    if [[ -z "$backup_name" ]]; then
        local timestamp
        timestamp=$(date +%Y%m%d_%H%M%S)
        backup_name="${container_name}_backup_${timestamp}"
    fi
    
    log_info "Starting container backup: $container_name -> $backup_dir/$backup_name"
    
    # COMMENT: Create backup directory for this container
    local container_backup_dir
    container_backup_dir="$backup_dir/$backup_name"
    
    if ! mkdir -p "$container_backup_dir" 2>/dev/null; then
        log_error "Failed to create container backup directory: $container_backup_dir"
        return 1
    fi
    
    # COMMENT: Set secure permissions on container backup directory
    if ! chmod 750 "$container_backup_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on container backup directory"
    fi
    
    # COMMENT: Export container filesystem
    local container_archive
    container_archive="$container_backup_dir/container_fs.tar"
    
    log_info "Exporting container filesystem: $container_name -> $container_archive"
    
    if docker export "$container_name" > "$container_archive" 2>/dev/null; then
        # COMMENT: Set secure permissions on archive
        if ! chmod 640 "$container_archive" 2>/dev/null; then
            log_warning "Failed to set secure permissions on container archive"
        fi
        
        log_success "Container filesystem exported: $container_archive"
    else
        log_error "Failed to export container filesystem: $container_name"
        return 1
    fi
    
    # COMMENT: Save container configuration
    local container_config
    container_config="$container_backup_dir/container_config.json"
    
    log_info "Saving container configuration: $container_name -> $container_config"
    
    if docker inspect "$container_name" > "$container_config" 2>/dev/null; then
        # COMMENT: Set secure permissions on config
        if ! chmod 640 "$container_config" 2>/dev/null; then
            log_warning "Failed to set secure permissions on container config"
        fi
        
        log_success "Container configuration saved: $container_config"
    else
        log_warning "Failed to save container configuration: $container_name"
    fi
    
    # COMMENT: Create backup metadata
    local backup_metadata
    backup_metadata="$container_backup_dir/backup_metadata.json"
    
    local metadata="{
        \"container_name\": \"$container_name\",
        \"backup_name\": \"$backup_name\",
        \"backup_timestamp\": \"$(date -u '+%Y-%m-%d %H:%M:%S UTC')\",
        \"environment\": \"$DOCKER_UTILS_ENVIRONMENT\",
        \"backup_files\": [
            \"container_fs.tar\",
            \"container_config.json\"
        ],
        \"backup_size\": \"$(du -sh "$container_backup_dir" 2>/dev/null | cut -f1 || echo 'unknown')\"
    }"
    
    if echo "$metadata" > "$backup_metadata" 2>/dev/null; then
        # COMMENT: Set secure permissions on metadata
        if ! chmod 640 "$backup_metadata" 2>/dev/null; then
            log_warning "Failed to set secure permissions on backup metadata"
        fi
        
        log_info "Backup metadata created: $backup_metadata"
    else
        log_warning "Failed to create backup metadata"
    fi
    
    # COMMENT: Compress backup directory
    local compressed_backup
    compressed_backup="$backup_dir/${backup_name}.tar.gz"
    
    log_info "Compressing backup: $container_backup_dir -> $compressed_backup"
    
    if tar -czf "$compressed_backup" -C "$backup_dir" "$backup_name" 2>/dev/null; then
        # COMMENT: Set secure permissions on compressed backup
        if ! chmod 640 "$compressed_backup" 2>/dev/null; then
            log_warning "Failed to set secure permissions on compressed backup"
        fi
        
        log_success "Backup compressed: $compressed_backup"
        
        # COMMENT: Remove uncompressed backup directory
        if ! rm -rf "$container_backup_dir" 2>/dev/null; then
            log_warning "Failed to remove uncompressed backup directory"
        fi
        
        log_success "Container backup completed successfully: $container_name -> $compressed_backup"
        return 0
    else
        log_error "Failed to compress backup: $container_backup_dir"
        return 1
    fi
}

# COMMENT: Production Docker container restore with validation
restore_container() {
    local backup_file="$1"
    local container_name="$2"
    local restore_path="${3:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$backup_file" ]]; then
        log_error "Backup file not specified for restoration"
        return 1
    fi
    
    if [[ -z "$container_name" ]]; then
        log_error "Container name not specified for restoration"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        log_error "Backup file not found: $backup_file"
        return 1
    fi
    
    # COMMENT: Sanitize container name for security
    container_name=$(echo "$container_name" | sed 's/[^a-zA-Z0-9._-]/_/g')
    
    if [[ -z "$container_name" ]]; then
        log_error "Invalid container name after sanitization"
        return 1
    fi
    
    # COMMENT: Check if container already exists
    if docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${container_name}$"; then
        log_error "Container already exists: $container_name"
        return 1
    fi
    
    log_info "Starting container restoration: $backup_file -> $container_name"
    
    # COMMENT: Create temporary restore directory
    local temp_restore_dir
    temp_restore_dir=$(mktemp -d "${TMPDIR:-/tmp}/docker_restore_XXXXXX" 2>/dev/null)
    
    if [[ ! -d "$temp_restore_dir" ]]; then
        log_error "Failed to create temporary restore directory"
        return 1
    fi
    
    # COMMENT: Set secure permissions on temp directory
    if ! chmod 750 "$temp_restore_dir" 2>/dev/null; then
        log_warning "Failed to set secure permissions on temp directory"
    fi
    
    # COMMENT: Extract backup
    log_info "Extracting backup: $backup_file -> $temp_restore_dir"
    
    if ! tar -xzf "$backup_file" -C "$temp_restore_dir" 2>/dev/null; then
        log_error "Failed to extract backup: $backup_file"
        rm -rf "$temp_restore_dir" 2>/dev/null
        return 1
    fi
    
    # COMMENT: Find extracted backup directory
    local extracted_dir
    extracted_dir=$(find "$temp_restore_dir" -maxdepth 1 -type d -name "*" | head -1)
    
    if [[ ! -d "$extracted_dir" ]]; then
        log_error "Failed to find extracted backup directory"
        rm -rf "$temp_restore_dir" 2>/dev/null
        return 1
    fi
    
    # COMMENT: Check for required backup files
    local container_archive container_config
    container_archive="$extracted_dir/container_fs.tar"
    container_config="$extracted_dir/container_config.json"
    
    if [[ ! -f "$container_archive" ]]; then
        log_error "Container archive not found in backup: $container_archive"
        rm -rf "$temp_restore_dir" 2>/dev/null
        return 1
    fi
    
    if [[ ! -f "$container_config" ]]; then
        log_error "Container config not found in backup: $container_config"
        rm -rf "$temp_restore_dir" 2>/dev/null
        return 1
    fi
    
    # COMMENT: Import container image
    local image_name
    image_name="restored_${container_name}_$(date +%Y%m%d_%H%M%S)"
    
    log_info "Importing container image: $container_archive -> $image_name"
    
    if ! docker import "$container_archive" "$image_name" >/dev/null 2>&1; then
        log_error "Failed to import container image: $container_archive"
        rm -rf "$temp_restore_dir" 2>/dev/null
        return 1
    fi
    
    log_success "Container image imported: $image_name"
    
    # COMMENT: Create container from image
    log_info "Creating container from image: $image_name -> $container_name"
    
    if ! docker create --name "$container_name" "$image_name" >/dev/null 2>&1; then
        log_error "Failed to create container: $container_name"
        docker rmi "$image_name" >/dev/null 2>&1
        rm -rf "$temp_restore_dir" 2>/dev/null
        return 1
    fi
    
    log_success "Container created successfully: $container_name"
    
    # COMMENT: Clean up temporary files
    if ! rm -rf "$temp_restore_dir" 2>/dev/null; then
        log_warning "Failed to remove temporary restore directory"
    fi
    
    # COMMENT: Remove imported image
    if ! docker rmi "$image_name" >/dev/null 2>&1; then
        log_warning "Failed to remove imported image: $image_name"
    fi
    
    log_success "Container restoration completed successfully: $backup_file -> $container_name"
    return 0
}

# COMMENT: Production Docker cleanup with validation
cleanup_docker() {
    local cleanup_type="${1:-all}"
    local dry_run="${2:-false}"
    
    # COMMENT: Input validation for security
    case "$cleanup_type" in
        all|containers|images|volumes|networks|build_cache)
            ;;
        *)
            log_error "Invalid cleanup type: $cleanup_type"
            return 1
            ;;
    esac
    
    log_info "Starting Docker cleanup (type: $cleanup_type, dry_run: $dry_run)"
    
    # COMMENT: Check Docker availability
    if ! check_docker_availability; then
        return 1
    fi
    
    # COMMENT: Perform cleanup based on type
    case "$cleanup_type" in
        containers|all)
            log_info "Cleaning up stopped containers"
            
            local stopped_containers
            stopped_containers=$(docker ps -a --filter "status=exited" --filter "status=created" --format "{{.Names}}" 2>/dev/null || true)
            
            if [[ -n "$stopped_containers" ]]; then
                local container_count
                container_count=$(echo "$stopped_containers" | wc -l)
                log_info "Found $container_count stopped containers"
                
                if [[ "$dry_run" == "true" ]]; then
                    log_info "Dry run - would remove containers:"
                    echo "$stopped_containers" | while read -r container; do
                        log_info "  $container"
                    done
                else
                    echo "$stopped_containers" | while read -r container; do
                        if docker rm "$container" >/dev/null 2>&1; then
                            log_info "Removed stopped container: $container"
                        else
                            log_warning "Failed to remove stopped container: $container"
                        fi
                    done
                fi
            else
                log_info "No stopped containers found"
            fi
            ;;
    esac
    
    case "$cleanup_type" in
        images|all)
            log_info "Cleaning up dangling images"
            
            local dangling_images
            dangling_images=$(docker images --filter "dangling=true" --format "{{.ID}}" 2>/dev/null || true)
            
            if [[ -n "$dangling_images" ]]; then
                local image_count
                image_count=$(echo "$dangling_images" | wc -l)
                log_info "Found $image_count dangling images"
                
                if [[ "$dry_run" == "true" ]]; then
                    log_info "Dry run - would remove images:"
                    echo "$dangling_images" | while read -r image; do
                        log_info "  $image"
                    done
                else
                    echo "$dangling_images" | while read -r image; do
                        if docker rmi "$image" >/dev/null 2>&1; then
                            log_info "Removed dangling image: $image"
                        else
                            log_warning "Failed to remove dangling image: $image"
                        fi
                    done
                fi
            else
                log_info "No dangling images found"
            fi
            ;;
    esac
    
    case "$cleanup_type" in
        volumes|all)
            log_info "Cleaning up unused volumes"
            
            if [[ "$dry_run" == "true" ]]; then
                log_info "Dry run - would remove unused volumes"
                docker volume ls --filter "dangling=true" 2>/dev/null || true
            else
                if docker volume prune -f >/dev/null 2>&1; then
                    log_success "Unused volumes cleaned up"
                else
                    log_warning "Failed to cleanup unused volumes"
                fi
            fi
            ;;
    esac
    
    case "$cleanup_type" in
        networks|all)
            log_info "Cleaning up unused networks"
            
            if [[ "$dry_run" == "true" ]]; then
                log_info "Dry run - would remove unused networks"
                docker network ls --filter "type=custom" 2>/dev/null || true
            else
                if docker network prune -f >/dev/null 2>&1; then
                    log_success "Unused networks cleaned up"
                else
                    log_warning "Failed to cleanup unused networks"
                fi
            fi
            ;;
    esac
    
    case "$cleanup_type" in
        build_cache|all)
            log_info "Cleaning up build cache"
            
            if [[ "$dry_run" == "true" ]]; then
                log_info "Dry run - would cleanup build cache"
            else
                if docker builder prune -f >/dev/null 2>&1; then
                    log_success "Build cache cleaned up"
                else
                    log_warning "Failed to cleanup build cache"
                fi
            fi
            ;;
    esac
    
    log_success "Docker cleanup completed successfully"
    return 0
}

# COMMENT: Production Docker health check with validation
check_docker_health() {
    log_info "Starting Docker health check"
    
    # COMMENT: Check Docker availability
    if ! check_docker_availability; then
        return 1
    fi
    
    # COMMENT: Check Docker daemon health
    local daemon_health
    daemon_health=$(docker info 2>/dev/null | grep -E "(Health|Status)" || echo "Status: unknown")
    log_info "Docker daemon health: $daemon_health"
    
    # COMMENT: Check running containers
    local running_containers
    running_containers=$(docker ps --format "{{.Names}}" 2>/dev/null | wc -l || echo "0")
    log_info "Running containers: $running_containers"
    
    # COMMENT: Check total containers
    local total_containers
    total_containers=$(docker ps -a --format "{{.Names}}" 2>/dev/null | wc -l || echo "0")
    log_info "Total containers: $total_containers"
    
    # COMMENT: Check container health status
    local unhealthy_containers
    unhealthy_containers=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" 2>/dev/null || true)
    
    if [[ -n "$unhealthy_containers" ]]; then
        local unhealthy_count
        unhealthy_count=$(echo "$unhealthy_containers" | wc -l)
        log_warning "Found $unhealthy_count unhealthy containers:"
        echo "$unhealthy_containers" | while read -r container; do
            log_warning "  $container"
        done
    else
        log_info "All running containers are healthy"
    fi
    
    # COMMENT: Check Docker system usage
    local system_usage
    system_usage=$(docker system df 2>/dev/null || true)
    
    if [[ -n "$system_usage" ]]; then
        log_info "Docker system usage:"
        echo "$system_usage" | while read -r line; do
            log_info "  $line"
        done
    fi
    
    log_success "Docker health check completed successfully"
    return 0
}

# COMMENT: Production Docker compose operations with validation
docker_compose_operation() {
    local operation="$1"
    local compose_file="${2:-}"
    local service_name="${3:-}"
    
    # COMMENT: Input validation for security
    case "$operation" in
        up|down|start|stop|restart|status|logs|ps|build|pull)
            ;;
        *)
            log_error "Invalid Docker Compose operation: $operation"
            return 1
            ;;
    esac
    
    # COMMENT: Set default compose file if not specified
    if [[ -z "$compose_file" ]]; then
        compose_file="$SCRIPT_DIR/../docker-compose.yml"
    fi
    
    # COMMENT: Validate compose file
    if [[ ! -f "$compose_file" ]]; then
        log_error "Docker Compose file not found: $compose_file"
        return 1
    fi
    
    # COMMENT: Check if docker-compose is available
    if ! command -v docker-compose >/dev/null 2>&1; then
        log_error "docker-compose command not available"
        return 1
    fi
    
    log_info "Executing Docker Compose operation: $operation (file: $compose_file)"
    
    # COMMENT: Execute compose operation
    local compose_cmd="docker-compose -f \"$compose_file\""
    
    case "$operation" in
        up)
            compose_cmd="$compose_cmd up -d"
            ;;
        down)
            compose_cmd="$compose_cmd down"
            ;;
        start)
            compose_cmd="$compose_cmd start"
            if [[ -n "$service_name" ]]; then
                compose_cmd="$compose_cmd $service_name"
            fi
            ;;
        stop)
            compose_cmd="$compose_cmd stop"
            if [[ -n "$service_name" ]]; then
                compose_cmd="$compose_cmd $service_name"
            fi
            ;;
        restart)
            compose_cmd="$compose_cmd restart"
            if [[ -n "$service_name" ]]; then
                compose_cmd="$compose_cmd $service_name"
            fi
            ;;
        status)
            compose_cmd="$compose_cmd ps"
            ;;
        logs)
            compose_cmd="$compose_cmd logs"
            if [[ -n "$service_name" ]]; then
                compose_cmd="$compose_cmd $service_name"
            fi
            ;;
        ps)
            compose_cmd="$compose_cmd ps"
            ;;
        build)
            compose_cmd="$compose_cmd build"
            if [[ -n "$service_name" ]]; then
                compose_cmd="$compose_cmd $service_name"
            fi
            ;;
        pull)
            compose_cmd="$compose_cmd pull"
            if [[ -n "$service_name" ]]; then
                compose_cmd="$compose_cmd $service_name"
            fi
            ;;
    esac
    
    log_info "Executing command: $compose_cmd"
    
    if eval "$compose_cmd"; then
        log_success "Docker Compose operation completed successfully: $operation"
        return 0
    else
        log_error "Docker Compose operation failed: $operation"
        return 1
    fi
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Docker Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive Docker functions for production use.
    It includes container management, backup/restore, cleanup, and health checks.

FUNCTIONS:
    check_docker_availability - Check Docker availability and version
    validate_docker_operation <operation> - Validate Docker operation
    validate_docker_container <name> - Validate Docker container
    check_container_status <name> - Check container status
    start_container <name> [timeout] - Start container
    stop_container <name> [force] [timeout] - Stop container
    restart_container <name> [timeout] - Restart container
    get_container_logs <name> [lines] [output] - Get container logs
    inspect_container <name> [output] - Inspect container
    backup_container <name> [dir] [name] - Backup container
    restore_container <file> <name> [path] - Restore container
    cleanup_docker [type] [dry_run] - Cleanup Docker resources
    check_docker_health - Check Docker system health
    docker_compose_operation <op> [file] [service] - Execute compose operation

DOCKER OPERATIONS:
    start, stop, restart, status, logs, inspect, exec, backup, restore, cleanup

CLEANUP TYPES:
    all, containers, images, volumes, networks, build_cache

COMPOSE OPERATIONS:
    up, down, start, stop, restart, status, logs, ps, build, pull

SECURITY FEATURES:
    - Input validation and sanitization
    - Container name sanitization
    - Secure file permissions
    - Docker security validation
    - Comprehensive error handling

EXAMPLES:
    source $SCRIPT_NAME
    check_docker_availability
    start_container "webapp" 60
    backup_container "database" "/backups" "db_backup"
    cleanup_docker "all" "false"
    docker_compose_operation "up" "/path/to/compose.yml"

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize Docker utilities if not already done
    if [[ -z "${DOCKER_UTILS_INITIALIZED:-}" ]]; then
        export DOCKER_UTILS_INITIALIZED="true"
        log_info "Docker utilities initialized successfully"
    fi
    
    # COMMENT: Log successful loading
    log_info "Docker utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@"
