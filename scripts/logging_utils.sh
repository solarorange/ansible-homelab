#!/bin/bash
# COMMENT: Production-ready Logging Utilities for Ansible Homelab
# COMMENT: Comprehensive logging functions with security validation and error handling
# COMMENT: Generated by: {{ ansible_managed }}
# COMMENT: Timestamp: {{ ansible_date_time.iso8601 }}
# COMMENT: Environment: {{ deployment_environment | default('production') }}

# COMMENT: Production security settings for logging reliability
set -euo pipefail  # COMMENT: Exit on error, undefined vars, pipe failures
IFS=$'\n\t'        # COMMENT: Secure Internal Field Separator
umask 077          # COMMENT: Restrictive file permissions

# COMMENT: Script metadata and configuration with security
SCRIPT_NAME="logging_utils.sh"
SCRIPT_VERSION="2.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# COMMENT: Production logging configuration with security
LOG_LEVELS=("DEBUG" "INFO" "WARNING" "ERROR" "CRITICAL" "SUCCESS")
DEFAULT_LOG_LEVEL="INFO"
LOG_FORMAT="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
LOG_DATE_FORMAT="%Y-%m-%d %H:%M:%S UTC"

# COMMENT: Production environment variables with validation
export LOG_UTILS_ENVIRONMENT="{{ deployment_environment | default('production') }}"
export LOG_UTILS_TIMESTAMP="$(date -u +%Y%m%d_%H%M%S)"

# COMMENT: Production logging function with validation and security
log() {
    local level="$1"
    local message="$2"
    local timestamp="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
    
    # COMMENT: Input validation and sanitization for security
    if [[ -z "$level" || -z "$message" ]]; then
        echo "ERROR: Invalid log parameters" >&2
        return 1
    fi
    
    # COMMENT: Sanitize log level for security
    case "$level" in
        DEBUG|INFO|WARNING|ERROR|CRITICAL|SUCCESS)
            ;;
        *)
            level="INFO"
            ;;
    esac
    
    # COMMENT: Sanitize message for security (remove potential injection)
    message=$(echo "$message" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Format log message with production standards
    local formatted_message="[$timestamp] [$level] $message"
    
    # COMMENT: Output to appropriate destinations based on level
    case "$level" in
        DEBUG)
            if [[ "${LOG_LEVEL:-$DEFAULT_LOG_LEVEL}" == "DEBUG" ]]; then
                echo "$formatted_message" >&2
            fi
            ;;
        INFO|SUCCESS)
            echo "$formatted_message"
            ;;
        WARNING)
            echo "$formatted_message" >&2
            ;;
        ERROR|CRITICAL)
            echo "$formatted_message" >&2
            ;;
    esac
    
    # COMMENT: Write to log file if configured
    if [[ -n "${LOG_FILE:-}" ]]; then
        echo "$formatted_message" >> "$LOG_FILE" 2>/dev/null || true
    fi
    
    # COMMENT: Send to system logger if available
    if command -v logger >/dev/null 2>&1; then
        case "$level" in
            DEBUG) logger -p user.debug "$message" ;;
            INFO|SUCCESS) logger -p user.info "$message" ;;
            WARNING) logger -p user.warning "$message" ;;
            ERROR) logger -p user.error "$message" ;;
            CRITICAL) logger -p user.crit "$message" ;;
        esac
    fi
}

# COMMENT: Production debug logging with security validation
log_debug() {
    local message="$1"
    local function_name="${FUNCNAME[1]:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$message" ]]; then
        echo "ERROR: Empty debug message" >&2
        return 1
    fi
    
    log "DEBUG" "[$function_name] $message"
}

# COMMENT: Production info logging with security validation
log_info() {
    local message="$1"
    local function_name="${FUNCNAME[1]:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$message" ]]; then
        echo "ERROR: Empty info message" >&2
        return 1
    fi
    
    log "INFO" "[$function_name] $message"
}

# COMMENT: Production warning logging with security validation
log_warning() {
    local message="$1"
    local function_name="${FUNCNAME[1]:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$message" ]]; then
        echo "ERROR: Empty warning message" >&2
        return 1
    fi
    
    log "WARNING" "[$function_name] $message"
}

# COMMENT: Production error logging with security validation
log_error() {
    local message="$1"
    local function_name="${FUNCNAME[1]:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$message" ]]; then
        echo "ERROR: Empty error message" >&2
        return 1
    fi
    
    log "ERROR" "[$function_name] $message"
}

# COMMENT: Production critical logging with security validation
log_critical() {
    local message="$1"
    local function_name="${FUNCNAME[1]:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$message" ]]; then
        echo "ERROR: Empty critical message" >&2
        return 1
    fi
    
    log "CRITICAL" "[$function_name] $message"
}

# COMMENT: Production success logging with security validation
log_success() {
    local message="$1"
    local function_name="${FUNCNAME[1]:-unknown}"
    
    # COMMENT: Input validation for security
    if [[ -z "$message" ]]; then
        echo "ERROR: Empty success message" >&2
        return 1
    fi
    
    log "SUCCESS" "[$function_name] $message"
}

# COMMENT: Production structured logging with security validation
log_structured() {
    local level="$1"
    local component="$2"
    local action="$3"
    local details="$4"
    local timestamp="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
    
    # COMMENT: Input validation for security
    if [[ -z "$level" || -z "$component" || -z "$action" ]]; then
        echo "ERROR: Invalid structured log parameters" >&2
        return 1
    fi
    
    # COMMENT: Sanitize inputs for security
    level=$(echo "$level" | sed 's/[^A-Z]/_/g')
    component=$(echo "$component" | sed 's/[^a-zA-Z0-9_]/_/g')
    action=$(echo "$action" | sed 's/[^a-zA-Z0-9_]/_/g')
    details=$(echo "$details" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Create structured log entry
    local structured_entry="{
        \"timestamp\": \"$timestamp\",
        \"level\": \"$level\",
        \"component\": \"$component\",
        \"action\": \"$action\",
        \"details\": \"$details\",
        \"environment\": \"$LOG_UTILS_ENVIRONMENT\",
        \"script\": \"$SCRIPT_NAME\",
        \"version\": \"$SCRIPT_VERSION\"
    }"
    
    # COMMENT: Output structured log
    case "$level" in
        DEBUG)
            if [[ "${LOG_LEVEL:-$DEFAULT_LOG_LEVEL}" == "DEBUG" ]]; then
                echo "$structured_entry" >&2
            fi
            ;;
        INFO|SUCCESS)
            echo "$structured_entry"
            ;;
        WARNING|ERROR|CRITICAL)
            echo "$structured_entry" >&2
            ;;
    esac
    
    # COMMENT: Write to log file if configured
    if [[ -n "${LOG_FILE:-}" ]]; then
        echo "$structured_entry" >> "$LOG_FILE" 2>/dev/null || true
    fi
}

# COMMENT: Production log file setup with security validation
setup_log_file() {
    local log_file="$1"
    local log_dir
    local log_file_name
    
    # COMMENT: Input validation for security
    if [[ -z "$log_file" ]]; then
        echo "ERROR: Log file path not specified" >&2
        return 1
    fi
    
    # COMMENT: Extract directory and filename
    log_dir=$(dirname "$log_file")
    log_file_name=$(basename "$log_file")
    
    # COMMENT: Create log directory if it doesn't exist
    if [[ ! -d "$log_dir" ]]; then
        if ! mkdir -p "$log_dir" 2>/dev/null; then
            echo "ERROR: Failed to create log directory: $log_dir" >&2
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on log directory
    if ! chmod 750 "$log_dir" 2>/dev/null; then
        echo "WARNING: Failed to set secure permissions on log directory: $log_dir" >&2
    fi
    
    # COMMENT: Create log file if it doesn't exist
    if [[ ! -f "$log_file" ]]; then
        if ! touch "$log_file" 2>/dev/null; then
            echo "ERROR: Failed to create log file: $log_file" >&2
            return 1
        fi
    fi
    
    # COMMENT: Set secure permissions on log file
    if ! chmod 640 "$log_file" 2>/dev/null; then
        echo "WARNING: Failed to set secure permissions on log file: $log_file" >&2
    fi
    
    # COMMENT: Set ownership if running as root
    if [[ $EUID -eq 0 ]] && [[ -n "${LOG_OWNER:-}" ]]; then
        if ! chown "$LOG_OWNER:$LOG_OWNER" "$log_file" 2>/dev/null; then
            echo "WARNING: Failed to set ownership on log file: $log_file" >&2
        fi
    fi
    
    # COMMENT: Export log file path
    export LOG_FILE="$log_file"
    
    # COMMENT: Log successful setup
    log_info "Log file setup completed: $log_file"
}

# COMMENT: Production log rotation with security validation
rotate_log_file() {
    local log_file="$1"
    local max_size_mb="${2:-100}"
    local max_files="${3:-5}"
    
    # COMMENT: Input validation for security
    if [[ -z "$log_file" ]] || [[ ! -f "$log_file" ]]; then
        return 0
    fi
    
    # COMMENT: Check if rotation is needed
    local current_size_mb
    current_size_mb=$(du -m "$log_file" 2>/dev/null | cut -f1 || echo "0")
    
    if [[ "$current_size_mb" -lt "$max_size_mb" ]]; then
        return 0
    fi
    
    # COMMENT: Perform log rotation
    local log_dir
    local log_file_name
    local log_file_ext
    
    log_dir=$(dirname "$log_file")
    log_file_name=$(basename "$log_file")
    log_file_ext="${log_file_name##*.}"
    log_file_name="${log_file_name%.*}"
    
    # COMMENT: Remove old rotated files
    local i
    for ((i=max_files; i>0; i--)); do
        local old_file="$log_dir/${log_file_name}.$i.$log_file_ext"
        if [[ -f "$old_file" ]]; then
            rm -f "$old_file" 2>/dev/null || true
        fi
    done
    
    # COMMENT: Shift existing rotated files
    for ((i=max_files-1; i>0; i--)); do
        local old_file="$log_dir/${log_file_name}.$i.$log_file_ext"
        local new_file="$log_dir/${log_file_name}.$((i+1)).$log_file_ext"
        if [[ -f "$old_file" ]]; then
            mv "$old_file" "$new_file" 2>/dev/null || true
        fi
    done
    
    # COMMENT: Rotate current log file
    local rotated_file="$log_dir/${log_file_name}.1.$log_file_ext"
    if ! mv "$log_file" "$rotated_file" 2>/dev/null; then
        log_warning "Failed to rotate log file: $log_file"
        return 1
    fi
    
    # COMMENT: Create new log file
    if ! touch "$log_file" 2>/dev/null; then
        log_warning "Failed to create new log file: $log_file"
        return 1
    fi
    
    # COMMENT: Set secure permissions on new log file
    if ! chmod 640 "$log_file" 2>/dev/null; then
        log_warning "Failed to set secure permissions on new log file: $log_file"
    fi
    
    # COMMENT: Set ownership if running as root
    if [[ $EUID -eq 0 ]] && [[ -n "${LOG_OWNER:-}" ]]; then
        if ! chown "$LOG_OWNER:$LOG_OWNER" "$log_file" 2>/dev/null; then
            log_warning "Failed to set ownership on new log file: $log_file"
        fi
    fi
    
    log_info "Log file rotated: $log_file -> $rotated_file"
}

# COMMENT: Production log cleanup with security validation
cleanup_logs() {
    local log_dir="$1"
    local max_age_days="${2:-30}"
    
    # COMMENT: Input validation for security
    if [[ -z "$log_dir" ]] || [[ ! -d "$log_dir" ]]; then
        return 0
    fi
    
    # COMMENT: Find and remove old log files
    if command -v find >/dev/null 2>&1; then
        if ! find "$log_dir" -name "*.log" -type f -mtime +"$max_age_days" -delete 2>/dev/null; then
            log_warning "Failed to cleanup old log files in: $log_dir"
            return 1
        fi
    fi
    
    log_info "Log cleanup completed for directory: $log_dir (max age: ${max_age_days} days)"
}

# COMMENT: Production log validation with security checks
validate_log_file() {
    local log_file="$1"
    
    # COMMENT: Input validation for security
    if [[ -z "$log_file" ]]; then
        return 1
    fi
    
    # COMMENT: Check if log file exists and is writable
    if [[ ! -f "$log_file" ]]; then
        return 1
    fi
    
    if [[ ! -w "$log_file" ]]; then
        return 1
    fi
    
    # COMMENT: Check log file permissions
    local permissions
    permissions=$(stat -c "%a" "$log_file" 2>/dev/null || stat -f "%Lp" "$log_file" 2>/dev/null)
    
    if [[ -z "$permissions" ]]; then
        return 1
    fi
    
    # COMMENT: Validate permissions are secure (640 or more restrictive)
    if [[ "$permissions" != "6"* ]] && [[ "$permissions" != "7"* ]]; then
        return 1
    fi
    
    return 0
}

# COMMENT: Production log level validation with security
is_log_level_enabled() {
    local requested_level="$1"
    local current_level="${LOG_LEVEL:-$DEFAULT_LOG_LEVEL}"
    
    # COMMENT: Input validation for security
    if [[ -z "$requested_level" ]]; then
        return 1
    fi
    
    # COMMENT: Define log level hierarchy
    local level_hierarchy=("DEBUG" "INFO" "WARNING" "ERROR" "CRITICAL" "SUCCESS")
    
    # COMMENT: Find requested level index
    local requested_index=-1
    local current_index=-1
    local i
    
    for ((i=0; i<${#level_hierarchy[@]}; i++)); do
        if [[ "${level_hierarchy[i]}" == "$requested_level" ]]; then
            requested_index=$i
        fi
        if [[ "${level_hierarchy[i]}" == "$current_level" ]]; then
            current_index=$i
        fi
    done
    
    # COMMENT: Check if requested level is enabled
    if [[ $requested_index -ge 0 ]] && [[ $current_index -ge 0 ]] && [[ $requested_index -ge $current_index ]]; then
        return 0
    else
        return 1
    fi
}

# COMMENT: Production log initialization with security validation
init_logging() {
    local log_file="${1:-}"
    local log_level="${2:-$DEFAULT_LOG_LEVEL}"
    local log_owner="${3:-}"
    
    # COMMENT: Validate log level
    case "$log_level" in
        DEBUG|INFO|WARNING|ERROR|CRITICAL|SUCCESS)
            ;;
        *)
            log_level="$DEFAULT_LOG_LEVEL"
            ;;
    esac
    
    # COMMENT: Export log level
    export LOG_LEVEL="$log_level"
    
    # COMMENT: Export log owner if specified
    if [[ -n "$log_owner" ]]; then
        export LOG_OWNER="$log_owner"
    fi
    
    # COMMENT: Setup log file if specified
    if [[ -n "$log_file" ]]; then
        if ! setup_log_file "$log_file"; then
            log_warning "Failed to setup log file: $log_file (logging to console only)"
        fi
    fi
    
    # COMMENT: Log successful initialization
    log_info "Logging initialized - Level: $LOG_LEVEL, File: ${LOG_FILE:-console only}"
}

# COMMENT: Production log summary with security validation
log_summary() {
    local component="$1"
    local action="$2"
    local status="$3"
    local details="${4:-}"
    
    # COMMENT: Input validation for security
    if [[ -z "$component" || -z "$action" || -z "$status" ]]; then
        echo "ERROR: Invalid log summary parameters" >&2
        return 1
    fi
    
    # COMMENT: Sanitize inputs for security
    component=$(echo "$component" | sed 's/[^a-zA-Z0-9_]/_/g')
    action=$(echo "$action" | sed 's/[^a-zA-Z0-9_]/_/g')
    status=$(echo "$status" | sed 's/[^a-zA-Z0-9_]/_/g')
    details=$(echo "$details" | sed 's/[^a-zA-Z0-9 ._\-:]/_/g')
    
    # COMMENT: Create summary log entry
    local summary_entry="{
        \"timestamp\": \"$(date -u '+%Y-%m-%d %H:%M:%S UTC')\",
        \"component\": \"$component\",
        \"action\": \"$action\",
        \"status\": \"$status\",
        \"details\": \"$details\",
        \"environment\": \"$LOG_UTILS_ENVIRONMENT\",
        \"script\": \"$SCRIPT_NAME\",
        \"version\": \"$SCRIPT_VERSION\"
    }"
    
    # COMMENT: Output summary log
    echo "$summary_entry"
    
    # COMMENT: Write to log file if configured
    if [[ -n "${LOG_FILE:-}" ]]; then
        echo "$summary_entry" >> "$LOG_FILE" 2>/dev/null || true
    fi
}

# COMMENT: Production usage display with comprehensive information
show_usage() {
    cat << EOF
Usage: source $SCRIPT_NAME [options]

Production Logging Utilities v$SCRIPT_VERSION

DESCRIPTION:
    This script provides comprehensive logging functions for production use.
    It includes security validation, structured logging, and log management.

FUNCTIONS:
    log <level> <message>           - Basic logging with level and message
    log_debug <message>             - Debug level logging
    log_info <message>              - Info level logging
    log_warning <message>           - Warning level logging
    log_error <message>             - Error level logging
    log_critical <message>          - Critical level logging
    log_success <message>           - Success level logging
    log_structured <level> <component> <action> <details> - Structured logging
    log_summary <component> <action> <status> [details]  - Summary logging

UTILITY FUNCTIONS:
    setup_log_file <path>           - Setup log file with security
    rotate_log_file <path> [max_size_mb] [max_files] - Rotate log files
    cleanup_logs <directory> [max_age_days] - Cleanup old log files
    validate_log_file <path>        - Validate log file security
    is_log_level_enabled <level>    - Check if log level is enabled
    init_logging [file] [level] [owner] - Initialize logging system

LOG LEVELS:
    DEBUG, INFO, WARNING, ERROR, CRITICAL, SUCCESS

SECURITY FEATURES:
    - Input validation and sanitization
    - Secure file permissions
    - Structured logging with validation
    - Log rotation and cleanup
    - Security-aware error handling

EXAMPLES:
    source $SCRIPT_NAME
    init_logging "/var/log/app.log" "INFO" "appuser"
    log_info "Application started successfully"
    log_structured "INFO" "database" "connection" "Connected to PostgreSQL"
    log_summary "deployment" "rollback" "completed" "All services restored"

EOF
}

# COMMENT: Production main function with comprehensive initialization
main() {
    # COMMENT: Check if script is being sourced
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        show_usage
        exit 0
    fi
    
    # COMMENT: Initialize logging if not already done
    if [[ -z "${LOG_LEVEL:-}" ]]; then
        init_logging
    fi
    
    # COMMENT: Log successful loading
    log_info "Logging utilities loaded successfully"
}

# COMMENT: Execute main function when sourced
main "$@" 