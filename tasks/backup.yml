---
# Backup Configuration for Enhanced Homelab
# Multi-layered backup strategy with encryption and monitoring
#
# This playbook implements a comprehensive backup strategy with:
# - Local and remote backups
# - Encryption using age
# - Automated backup scheduling
# - Backup verification and integrity checks
# - Retention policies
# - Monitoring and alerting
#
# Architecture:
# 1. Backup Types:
#    - Docker configurations and volumes
#    - Application data
#    - System configuration
#    - User data
#
# 2. Storage Locations:
#    - Local storage for quick recovery
#    - Remote storage for disaster recovery
#    - Encrypted backups for security
#
# 3. Backup Components:
#    - Full system backups
#    - Incremental backups
#    - Differential backups
#    - Snapshot-based backups
#
# 4. Monitoring & Verification:
#    - Backup success/failure monitoring
#    - Integrity verification
#    - Space monitoring
#    - Alert notifications
#
# Prerequisites:
# - Sufficient storage space
# - Remote storage access
# - Encryption keys
# - Backup monitoring system

- name: Install backup utilities
  ansible.builtin.package:
    name:
      - rsync        # Fast, versatile file copying tool
      - rclone       # Cloud storage synchronization
      - gpg          # GNU Privacy Guard for encryption
      - tar          # Archive creation and extraction
      - gzip         # Compression utility
      - bzip2        # Alternative compression
      - xz-utils     # High compression ratio
      - zip          # ZIP archive support
      - unzip        # ZIP extraction
      - borgbackup   # Deduplicating backup program
      - restic       # Fast, secure, efficient backup
      - duplicity    # Encrypted bandwidth-efficient backup
      - age          # Modern encryption tool
    state: present
  # Installs all necessary backup and encryption utilities
  # Each tool serves a specific purpose in the backup strategy

- name: Create backup directory structure
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0750'
    owner: "{{ backup_user | default(ansible_user) }}"
    group: "{{ backup_group | default(ansible_user) }}"
  loop:
    - "{{ backup_root_dir | default('/var/backups') }}/system"
    - "{{ backup_root_dir | default('/var/backups') }}/configs"
    - "{{ backup_root_dir | default('/var/backups') }}/databases"
    - "{{ backup_root_dir | default('/var/backups') }}/docker"
    - "{{ backup_root_dir | default('/var/backups') }}/verification"
  tags: [backup, setup]

- name: Install backup dependencies
  ansible.builtin.package:
    name: "{{ item }}"
    state: present
  loop:
    - rsync
    - tar
    - gzip
    - bzip2
    - python3-pip
  tags: [backup, setup]

- name: Install Python backup dependencies
  ansible.builtin.pip:
    name: "{{ item }}"
    state: present
  loop:
    - boto3
    - paramiko
  tags: [backup, setup]

- name: Create backup configuration
  ansible.builtin.template:
    src: templates/backup_config.yml.j2
    dest: "{{ backup_root_dir | default('/var/backups') }}/config/backup_config.yml"
    mode: '0640'
    owner: "{{ backup_user | default(ansible_user) }}"
    group: "{{ backup_group | default(ansible_user) }}"
  tags: [backup, setup]

- name: Backup system configuration files
  ansible.builtin.archive:
    path: "{{ item }}"
    dest: "{{ backup_root_dir | default('/var/backups') }}/configs/{{ inventory_hostname }}-configs-{{ ansible_date_time.iso8601_basic_short }}.tar.gz"
    format: gz
  loop:
    - /etc
    - /var/lib/docker
    - "{{ backup_root_dir | default('/var/backups') }}/config"
  tags: [backup, configs]

- name: Backup Docker volumes
  ansible.builtin.shell: |
    docker run --rm -v {{ item }}:/source:ro -v {{ backup_root_dir | default('/var/backups') }}/docker:/backup alpine tar czf /backup/{{ item | basename }}-{{ ansible_date_time.iso8601_basic_short }}.tar.gz -C /source .
  loop: "{{ docker_volumes | default([]) }}"
  tags: [backup, docker]

- name: Backup databases
  ansible.builtin.include_tasks: tasks/backup_databases.yml
  tags: [backup, databases]

- name: Verify backup integrity
  ansible.builtin.include_tasks: tasks/verify_backups.yml
  tags: [backup, verification]

- name: Apply backup retention policy
  ansible.builtin.include_tasks: tasks/backup_retention.yml
  tags: [backup, retention]

- name: Setup backup scheduling
  ansible.builtin.template:
    src: templates/backup_cron.j2
    dest: /etc/cron.d/ansible-backups
    mode: '0640'
    owner: root
    group: root
  tags: [backup, scheduling]

- name: Create backup verification report
  ansible.builtin.template:
    src: templates/backup_report.j2
    dest: "{{ backup_root_dir | default('/var/backups') }}/reports/backup-report-{{ ansible_date_time.iso8601_basic_short }}.html"
    mode: '0640'
    owner: "{{ backup_user | default(ansible_user) }}"
    group: "{{ backup_group | default(ansible_user) }}"
  tags: [backup, reporting]

- name: Notify backup completion
  ansible.builtin.include_tasks: tasks/notify_backup.yml
  tags: [backup, notification]

- name: Generate backup encryption key
  block:
    - name: Check if backup key exists
      ansible.builtin.stat:
        path: "{{ backup_dir }}/backup.key"
      register: backup_key_stat
      # Checks if an encryption key already exists
      # Prevents overwriting existing keys

    - name: Generate backup encryption key
      ansible.builtin.shell: |
        openssl rand -base64 32 > {{ backup_dir }}/backup.key
        chmod 600 {{ backup_dir }}/backup.key
        chown {{ username }}:{{ username }} {{ backup_dir }}/backup.key
      when: not backup_key_stat.stat.exists
      # Generates a secure random key for backup encryption
      # Sets proper permissions and ownership
      # Only runs if no key exists

- name: Create comprehensive backup script
  ansible.builtin.copy:
    content: |
      #!/bin/bash
      # Comprehensive backup script for homelab
      # 
      # This script implements a multi-layered backup strategy:
      # 1. Docker configurations and volumes
      # 2. Application data
      # 3. System configuration
      # 4. User data
      #
      # Features:
      # - Encryption using age
      # - Compression using tar and gzip
      # - Logging of all operations
      # - Cleanup of old backups
      # - Error handling and reporting
      
      set -euo pipefail
      
      # Configuration
      BACKUP_DIR="{{ backup_dir }}"
      DOCKER_DIR="{{ docker_dir }}"
      DATA_DIR="{{ data_dir }}"
      CONFIG_DIR="{{ config_dir }}"
      LOG_FILE="$BACKUP_DIR/logs/backup-$(date +%Y%m%d-%H%M%S).log"
      RETENTION_DAYS="{{ backup_retention_days }}"
      ENCRYPT_KEY="$BACKUP_DIR/backup.key"
      
      # Functions
      log() {
          echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
      }
      # Logs messages to both console and log file
      # Includes timestamp for each entry
      
      cleanup() {
          log "Cleaning up temporary files"
          rm -rf "$BACKUP_DIR/temp/*"
          find "$BACKUP_DIR/local" -name "*.backup" -mtime +$RETENTION_DAYS -delete
          find "$BACKUP_DIR/logs" -name "*.log" -mtime +30 -delete
      }
      # Cleans up temporary files and old backups
      # Implements retention policy for backups and logs
      
      backup_docker_configs() {
          log "Backing up Docker configurations"
          local backup_name="docker-configs-$(date +%Y%m%d-%H%M%S).tar.gz"
          
          tar -czf "$BACKUP_DIR/local/$backup_name" \
              -C "$(dirname $DOCKER_DIR)" \
              "$(basename $DOCKER_DIR)" \
              --exclude="*/logs/*" \
              --exclude="*/cache/*" \
              --exclude="*/tmp/*"
          
          # Encrypt backup
          if [ -f "$ENCRYPT_KEY" ]; then
              age -r "$(cat $ENCRYPT_KEY)" -o "$BACKUP_DIR/local/$backup_name.age" "$BACKUP_DIR/local/$backup_name"
              rm "$BACKUP_DIR/local/$backup_name"
              log "Docker configs backup encrypted: $backup_name.age"
          else
              log "Docker configs backup created: $backup_name"
          fi
      }
      # Backs up Docker configurations
      # Excludes logs, cache, and temporary files
      # Encrypts the backup if encryption key exists
      
      backup_application_data() {
          log "Backing up application data"
          local backup_name="app-data-$(date +%Y%m%d-%H%M%S).tar.gz"
          
          # Create list of important data to backup
          cat > "$BACKUP_DIR/temp/backup-list.txt" << EOF
      $CONFIG_DIR
      /home/{{ username }}/.ssh
      /etc/systemd/system/homelab*
      /etc/nginx/sites-available/homelab*
      /etc/fail2ban/jail.local
      /etc/ufw/user.rules
      EOF
          
          tar -czf "$BACKUP_DIR/local/$backup_name" \
              -T "$BACKUP_DIR/temp/backup-list.txt" \
              --ignore-failed-read
          
          # Encrypt backup
          if [ -f "$ENCRYPT_KEY" ]; then
              age -r "$(cat $ENCRYPT_KEY)" -o "$BACKUP_DIR/local/$backup_name.age" "$BACKUP_DIR/local/$backup_name"
              rm "$BACKUP_DIR/local/$backup_name"
              log "Application data backup encrypted: $backup_name.age"
          else
              log "Application data backup created: $backup_name"
          fi
      }
      # Backs up application data and configurations
      # Includes SSH keys, systemd services, and security configs
      # Encrypts the backup if encryption key exists
      
      backup_docker_volumes() {
          log "Backing up Docker volumes"
          local backup_name="docker-volumes-$(date +%Y%m%d-%H%M%S).tar.gz"
          
          # Stop containers gracefully
          log "Stopping containers for volume backup"
          cd "$DOCKER_DIR"
          docker-compose stop
          
          # Backup volumes
          docker run --rm \
              -v "$BACKUP_DIR/local:/backup" \
              -v /var/lib/docker/volumes:/volumes:ro \
              alpine tar czf "/backup/$backup_name" -C /volumes .
          
          # Restart containers
          log "Restarting containers"
          docker-compose up -d
          
          # Encrypt backup
          if [ -f "$ENCRYPT_KEY" ]; then
              age -r "$(cat $ENCRYPT_KEY)" -o "$BACKUP_DIR/local/$backup_name.age" "$BACKUP_DIR/local/$backup_name"
              rm "$BACKUP_DIR/local/$backup_name"
              log "Docker volumes backup encrypted: $backup_name.age"
          else
              log "Docker volumes backup created: $backup_name"
          fi
      }
      # Backs up Docker volumes
      # Stops containers before backup
      # Restarts containers after backup
      # Encrypts the backup if encryption key exists
      
      backup_system_config() {
          log "Backing up system configuration"
          local backup_name="system-config-$(date +%Y%m%d-%H%M%S).tar.gz"
          
          tar -czf "$BACKUP_DIR/local/$backup_name" \
              /etc/fstab \
              /etc/hosts \
              /etc/hostname \
              /etc/ssh/sshd_config \
              /etc/sudoers \
              /etc/systemd/system \
              /etc/cron.d \
              /etc/logrotate.d \
              --ignore-failed-read
          
          # Encrypt backup
          if [ -f "$ENCRYPT_KEY" ]; then
              age -r "$(cat $ENCRYPT_KEY)" -o "$BACKUP_DIR/local/$backup_name.age" "$BACKUP_DIR/local/$backup_name"
              rm "$BACKUP_DIR/local/$backup_name"
              log "System config backup encrypted: $backup_name.age"
          else
              log "System config backup created: $backup_name"
          fi
      }
      # Backs up system configuration files
      # Includes network, security, and system settings
      # Encrypts the backup if encryption key exists
      
      create_backup_manifest() {
          log "Creating backup manifest"
          local manifest_file="$BACKUP_DIR/local/manifest-$(date +%Y%m%d-%H%M%S).txt"
          
          cat > "$manifest_file" << EOF
      Backup Manifest - $(date)
      ========================
      
      System Information:
      - Hostname: $(hostname)
      - Kernel: $(uname -r)
      - OS: $(lsb_release -d | cut -f2)
      - Backup Date: $(date)
      
      Backup Contents:
      - Docker Configurations: $BACKUP_DIR/local/docker-configs-*.age
      - Application Data: $BACKUP_DIR/local/app-data-*.age
      - Docker Volumes: $BACKUP_DIR/local/docker-volumes-*.age
      - System Configuration: $BACKUP_DIR/local/system-config-*.age
      
      Backup Statistics:
      - Total Size: $(du -sh $BACKUP_DIR/local | cut -f1)
      - Number of Files: $(find $BACKUP_DIR/local -type f | wc -l)
      - Oldest Backup: $(find $BACKUP_DIR/local -type f -name "*.age" -printf '%T+ %p\n' | sort | head -n1)
      - Newest Backup: $(find $BACKUP_DIR/local -type f -name "*.age" -printf '%T+ %p\n' | sort | tail -n1)
      
      Verification:
      - All backups are encrypted
      - Retention policy: $RETENTION_DAYS days
      - Backup location: $BACKUP_DIR/local
      EOF
          
          log "Backup manifest created: $manifest_file"
      }
      # Creates a detailed manifest of the backup
      # Includes system information and backup statistics
      # Helps with backup verification and tracking
      
      # Main backup process
      main() {
          log "Starting backup process"
          
          # Create backup directories if they don't exist
          mkdir -p "$BACKUP_DIR"/{local,remote,logs,temp}
          
          # Run backup tasks
          backup_docker_configs
          backup_application_data
          backup_docker_volumes
          backup_system_config
          
          # Create manifest
          create_backup_manifest
          
          # Cleanup
          cleanup
          
          log "Backup process completed successfully"
      }
      
      # Run main function
      main "$@"
    dest: "{{ backup_dir }}/scripts/backup.sh"
    owner: "{{ username }}"
    group: "{{ username }}"
    mode: "0750"
  # Creates the main backup script
  # Implements the complete backup strategy
  # Sets proper permissions for security

- name: Create backup monitoring script
  ansible.builtin.copy:
    content: |
      #!/bin/bash
      # Backup monitoring script
      #
      # This script monitors the backup system:
      # - Checks backup success/failure
      # - Verifies backup integrity
      # - Monitors storage space
      # - Sends alerts if needed
      
      set -euo pipefail
      
      # Configuration
      BACKUP_DIR="{{ backup_dir }}"
      LOG_FILE="$BACKUP_DIR/logs/monitor-$(date +%Y%m%d).log"
      ALERT_EMAIL="{{ alert_email }}"
      SPACE_THRESHOLD=90  # Alert when storage is 90% full
      
      # Functions
      log() {
          echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
      }
      
      check_backup_success() {
          local latest_log=$(ls -t "$BACKUP_DIR/logs/backup-"*.log 2>/dev/null | head -n1)
          
          if [ -z "$latest_log" ]; then
              log "ERROR: No backup logs found"
              return 1
          fi
          
          if grep -q "Backup process completed successfully" "$latest_log"; then
              log "Latest backup completed successfully"
              return 0
          else
              log "ERROR: Latest backup may have failed"
              return 1
          fi
      }
      
      verify_backup_integrity() {
          local latest_backup=$(find "$BACKUP_DIR/local" -type f -name "*.age" -printf '%T+ %p\n' | sort | tail -n1 | cut -d' ' -f2-)
          
          if [ -z "$latest_backup" ]; then
              log "ERROR: No encrypted backups found"
              return 1
          fi
          
          if age -d -i "$BACKUP_DIR/backup.key" "$latest_backup" > /dev/null; then
              log "Latest backup integrity verified"
              return 0
          else
              log "ERROR: Latest backup integrity check failed"
              return 1
          fi
      }
      
      check_storage_space() {
          local space_used=$(df -h "$BACKUP_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')
          
          if [ "$space_used" -ge "$SPACE_THRESHOLD" ]; then
              log "WARNING: Backup storage is $space_used% full"
              return 1
          else
              log "Backup storage space OK: $space_used% used"
              return 0
          fi
      }
      
      send_alert() {
          local subject="$1"
          local message="$2"
          
          if [ -n "$ALERT_EMAIL" ]; then
              echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
              log "Alert sent to $ALERT_EMAIL"
          else
              log "No alert email configured"
          fi
      }
      
      # Main monitoring process
      main() {
          log "Starting backup monitoring"
          
          local alerts=()
          
          # Check backup success
          if ! check_backup_success; then
              alerts+=("Backup success check failed")
          fi
          
          # Verify backup integrity
          if ! verify_backup_integrity; then
              alerts+=("Backup integrity check failed")
          fi
          
          # Check storage space
          if ! check_storage_space; then
              alerts+=("Storage space check failed")
          fi
          
          # Send alerts if any checks failed
          if [ ${#alerts[@]} -gt 0 ]; then
              local alert_message="Backup monitoring alerts:\n\n"
              for alert in "${alerts[@]}"; do
                  alert_message+="- $alert\n"
              done
              send_alert "Backup Monitoring Alert" "$alert_message"
          else
              log "All backup checks passed"
          fi
      }
      
      # Run main function
      main "$@"
    dest: "{{ backup_dir }}/scripts/monitor.sh"
    owner: "{{ username }}"
    group: "{{ username }}"
    mode: "0750"
  # Creates the backup monitoring script
  # Implements monitoring and alerting
  # Sets proper permissions for security

- name: Schedule backup tasks
  ansible.builtin.cron:
    name: "Daily backup"
    minute: "0"
    hour: "2"
    job: "{{ backup_dir }}/scripts/backup.sh"
    user: "{{ vault_service_user }}"
  # Schedules daily backups at 2 AM
  # Allows for system quiescence during backup

- name: Schedule backup monitoring
  ansible.builtin.cron:
    name: "Backup monitoring"
    minute: "*/30"
    job: "{{ backup_dir }}/scripts/monitor.sh"
    user: "{{ vault_service_user }}"
  # Schedules backup monitoring every 30 minutes
  # Ensures timely detection of issues

# Pre-deployment backup tasks
- name: Create backup directory
  ansible.builtin.file:
    path: "{{ backup_dir }}"
    state: directory
    mode: '0755'
  register: backup_dir_creation

- name: Backup current configuration
  ansible.builtin.archive:
    path: "{{ item }}"
    dest: "{{ backup_dir }}/{{ inventory_hostname }}-{{ ansible_date_time.iso8601_basic_short }}-{{ item | basename }}.tar.gz"
    format: gz
  loop:
    - /etc/docker
    - /etc/ansible
    - /etc/systemd/system
    - /opt
  when: backup_dir_creation is success
  register: backup_result

- name: Verify backup completion
  ansible.builtin.stat:
    path: "{{ item.dest }}"
  loop: "{{ backup_result.results }}"
  register: backup_verification
  failed_when: not item.stat.exists

- name: Cleanup old backups
  ansible.builtin.find:
    paths: "{{ backup_dir }}"
    patterns: "{{ inventory_hostname }}-*.tar.gz"
    age: "30d"
  register: old_backups

- name: Remove old backups
  ansible.builtin.file:
    path: "{{ item.path }}"
    state: absent
  loop: "{{ old_backups.files }}"
  when: old_backups.files | length > 0

- name: Log backup status
  ansible.builtin.debug:
    msg: "Backup completed successfully. Files backed up: {{ backup_result.results | map(attribute='dest') | list }}"
  when: backup_verification is success